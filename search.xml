<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Webpack 知识点</title>
      <link href="/2019/10/24/%E6%80%BB%E7%BB%93/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2019/10/24/%E6%80%BB%E7%BB%93/%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack-知识点"><a href="#webpack-知识点" class="headerlink" title="webpack 知识点"></a>webpack 知识点</h1><h3 id="webpack-的-loader-和-plugin-的区别"><a href="#webpack-的-loader-和-plugin-的区别" class="headerlink" title="webpack 的 loader 和 plugin 的区别"></a>webpack 的 loader 和 plugin 的区别</h3><blockquote><p><strong>loader</strong>是对源码层面的转换、webpack 只能识别 js 和 json 文件、其他字资源文件比如 css、 ts 等则需要 loader 进行转换，loader 更像是一个<strong>翻译器</strong>，将各种类型的语言翻译成 webpack 可以识别的类型<br><strong>plugin</strong>是对 loader 无法实现的功能的补充、通常有各自独立的功能，比如热加载插件，plugin 更像是一个<strong>增值套件</strong>。提供特定的增值服务。<br>plugin 可以自定义打包过程的方式，可以参加到整个生命流程中</p></blockquote><h3 id="webpack-原理"><a href="#webpack-原理" class="headerlink" title="webpack 原理"></a>webpack 原理</h3><p><a href="https://zhuanlan.zhihu.com/p/58151131?utm_source=com.daimajia.gold&utm_medium=social&utm_oi=631273285770547200" target="_blank" rel="noopener">理解webpack原理，手写一个100行的webpack - 知乎</a></p><ol><li>Webpack 的打包需要配置一个 entry，根据 entry 配置的文件目录读取文件的内容</li><li>读取到的内容是字符串，调用 babylon 来生产对应的 ast，ast 中包含依赖的文件</li><li>将依赖文件循环调用，生成模块 id 和依赖路径的关联信息，例如<pre><code class="javascript">{<span class="string">"1"</span>: <span class="string">"./abc.js"</span> }</code></pre>模拟 commonJs 的加载机制，将代码翻译成可以在浏览器里执行的样子 require 接收一个模块 id 然后从之前保存的依赖关联信息中找到并执行模块代码</li></ol><h3 id="什么是-webpack-和-grunt-和-gulp-有什么不同"><a href="#什么是-webpack-和-grunt-和-gulp-有什么不同" class="headerlink" title="什么是 webpack 和 grunt 和 gulp 有什么不同"></a>什么是 webpack 和 grunt 和 gulp 有什么不同</h3><p>Webpack 与 grunt 的 gulp 最大的不同各自的侧重点不同 grunt 和 gulp 是侧重在流程控制， webpack 侧重在打包机制。 其中 webpack 的 loader 和 gulp 的流程控制类似。</p><h3 id="bundle、chunk、module"><a href="#bundle、chunk、module" class="headerlink" title="bundle、chunk、module"></a>bundle、chunk、module</h3><ul><li>bundle 是 webpack 打包出来的文件 </li><li>chunk 是 webpack 代码分割出来的代码块</li><li>Module 是开发过程中的模块</li></ul><h3 id="webpack-dev-server-的优点"><a href="#webpack-dev-server-的优点" class="headerlink" title="webpack-dev-server 的优点"></a>webpack-dev-server 的优点</h3><p>在内存中存储开发环境下打包生成的文件、可以实现热更新。</p><h3 id="模块热加载的原理"><a href="#模块热加载的原理" class="headerlink" title="模块热加载的原理"></a>模块热加载的原理</h3><ol><li>启动本地服务，当浏览器发起请求资源的请求时作出响应。</li><li>webpack-dev-server 启动服务，与客户端形成 websocket 长连接</li><li>webpack 监听本地文件变化，以触发重新编译，生成新的 hash 值和编译后已改动的文件，推送客户端消息编译完成。</li><li>客户端对比接收到的消息，一致缓存、不一致发起 ajax 请求和 jsonp 请求来做最新替换。</li><li>本地服务，替换存在内存中的文件内容实现实时刷新。</li></ol><h3 id="webpack-持久化缓存"><a href="#webpack-持久化缓存" class="headerlink" title="webpack 持久化缓存"></a>webpack 持久化缓存</h3><p><a href="https://blog.csdn.net/VhWfR2u02Q/article/details/79081143" target="_blank" rel="noopener">Webpack 持久化缓存实践 - 前端大全 - CSDN博客</a></p><ul><li>保证业务静态资源文件的 hash 值变化，既每次发布都有唯一的 hash 值</li></ul><h3 id="webpack-loader-的书写顺序有什么讲究吗，style-loader必须放在css-loader-之前吗"><a href="#webpack-loader-的书写顺序有什么讲究吗，style-loader必须放在css-loader-之前吗" class="headerlink" title="webpack loader 的书写顺序有什么讲究吗，style-loader必须放在css-loader 之前吗"></a>webpack loader 的书写顺序有什么讲究吗，style-loader必须放在css-loader 之前吗</h3><ul><li>webpack loader 的加载顺序采用的是从右到左，是通过函数式编程中的 compose 来实现的，所以在书写的时候需要按照从右向左的顺序来，css-loader 在右，先处理，完成之后再交给 style-loader 处理，顺序不能调整</li></ul>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>「开发模式的工作原理是？」</title>
      <link href="/2019/10/24/%E7%BF%BB%E8%AF%91/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%EF%BC%9F/"/>
      <url>/2019/10/24/%E7%BF%BB%E8%AF%91/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="https://overreacted.io/how-does-the-development-mode-work/" target="_blank" rel="noopener">开发模式的工作原理是什么？</a></li><li>原文作者：<a href="https://mobile.twitter.com/dan_abramov" target="_blank" rel="noopener">Dan Abramov</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/how-does-the-development-mode-work.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/how-does-the-development-mode-work.md</a></li><li>译者：<a href="https://github.com/Jerry-FD" target="_blank" rel="noopener">Jerry-FD</a></li><li>校对者：<a href="https://github.com/TokenJan" target="_blank" rel="noopener">TokenJan</a>、<a href="https://github.com/hanxiaosss" target="_blank" rel="noopener">hanxiaosss</a></li></ul></blockquote><h1 id="开发模式的工作原理是？"><a href="#开发模式的工作原理是？" class="headerlink" title="开发模式的工作原理是？"></a>开发模式的工作原理是？</h1><p>如果你的 JavaScript 代码库已经有些复杂了，<strong>你可能需要一个解决方案来针对线上和开发环境区分打包和运行不同代码</strong>。</p><p>针对开发环境和线上环境，来区分打包和运行不同的代码非常有用。在开发模式中，React 会包含很多告警来帮助你及时发现问题，而不至于造成线上 bug。然而，这些帮助发现问题的必要代码，往往会造成代码包大小增加以及应用运行变慢。</p><p>这种降速在开发环境下是可以接受的。事实上，在开发环境下运行代码的速度更慢<strong>可能更有帮助</strong>，因为这可以一定程度上消除高性能的开发机器与平均速度的用户设备而带来的差异。</p><p>在线上环境我们不想要任何的性能损耗。因此，我们在线上环境删除了这些校验。那么它的工作原理是什么？让我们来康康。</p><hr><p>想要在开发环境运行下不同代码关键在于你的 JavaScript 构建工具（无论你用的是哪一个）。在 Facebook 中它长这个样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">  doSomethingDev();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  doSomethingProd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，<code>__DEV__</code> 不是一个真正的变量。当浏览器把模块之间的依赖加载完毕的时候，它会被替换成常量。结果是这个样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在开发环境下：</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  doSomethingDev(); <span class="comment">// 👈</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  doSomethingProd();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在线上环境：</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  doSomethingDev();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  doSomethingProd(); <span class="comment">// 👈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在线上环境，你可能会在代码中会启用压缩工具（比如, <a href="https://github.com/terser-js/terser" target="_blank" rel="noopener">terser</a>）。大多 JavaScript 压缩工具会针对<a href="https://en.wikipedia.org/wiki/Dead_code_elimination" target="_blank" rel="noopener">无效代码</a>做一些限制，比如删除 <code>if (false)</code> 的逻辑分支。所以在线上环境中，你可能只会看到：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在线上环境（压缩后）：</span></span><br><span class="line">doSomethingProd();</span><br></pre></td></tr></table></figure><p><strong>（注意，针对目前主流的 JavaScript 工具有一些重要的规范，这些规范可以指导怎样才能有效的移除无效代码，但这是另一个的话题了。）</strong></p><p>可能你使用的不是 <code>__DEV__</code> 这个神奇的变量，如果你是用的是流行的 JavaScript 打包工具，比如 webpack，那么这有一些你需要遵守的约定。比如，像这样的一种非常常见的表达式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  doSomethingDev();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  doSomethingProd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一些框架比如 <a href="https://reactjs.org/docs/optimizing-performance.html#use-the-production-build" target="_blank" rel="noopener">React</a> 和 <a href="https://vuejs.org/v2/guide/deployment.html#Turn-on-Production-Mode" target="_blank" rel="noopener">Vue</a> 就是使用的这种形式。当你使用 npm 来打包载入它们的时候。</strong> (单个的 <code>&lt;script&gt;</code> 标签会提供开发和线上版本的独立文件，并且使用 <code>.js</code> 和 <code>.min.js</code> 的结尾来作为区分。)</p><p>这个特殊的约定最早来自于 Node.js。在 Node.js 中，会有一个全局的 <code>process</code> 变量用来代表你当前系统的环境变量，它属于 <a href="https://nodejs.org/dist/latest-v8.x/docs/api/process.html#process_process_env" target="_blank" rel="noopener"><code>process.env</code></a> object 的一个属性。然而，如果你在前端的代码库里看到这种语法，其实是并不存在真正的 <code>process</code> 变量的。🤯</p><p>取而代之的是，整个 <code>process.env.NODE_ENV</code> 表达式在打包的时候会被替换成一个字面量的字符串，就像神奇的 <code>__DEV__</code> 变量一样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在开发环境中：</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'development'</span> !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  <span class="comment">// true</span></span><br><span class="line">  doSomethingDev(); <span class="comment">// 👈</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  doSomethingProd();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在线上环境中：</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'production'</span> !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  <span class="comment">// false</span></span><br><span class="line">  doSomethingDev();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  doSomethingProd(); <span class="comment">// 👈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为整个表达式是常量（<code>&#39;production&#39; !== &#39;production&#39;</code> 恒为 <code>false</code>）打包压缩工具也可以借此删除其他的逻辑分支代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在线上环境（打包压缩后）：</span></span><br><span class="line">doSomethingProd();</span><br></pre></td></tr></table></figure><p>恶作剧到此结束~</p><hr><p>注意这个特性如果面对更复杂的表达式将<strong>不会工作</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mode = <span class="string">'production'</span>;</span><br><span class="line"><span class="keyword">if</span> (mode !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  <span class="comment">// 🔴 不能保证会被移除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaScript 静态分析工具不是特别智能，这是因为语言的动态特性所决定的。当它们发现像 <code>mode</code> 这样的变量，而不是像 <code>false</code> 或者 <code>&#39;production&#39; !== &#39;production&#39;</code> 这样的静态表达式时，它们大概率会失效。</p><p>类似地，在 JavaScript 中如果你使用顶层的 <code>import</code> 声明，自动移除无用代码的逻辑会因为不能跨越模块边界而无法生效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 🔴 不能保证会被移除</span></span><br><span class="line"><span class="keyword">import</span> &#123; someFunc &#125; <span class="keyword">from</span> <span class="string">'some-module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  someFunc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以你的代码需要写的非常严格，来确保条件的<strong>绝对静态</strong>，并且确保<strong>所有</strong>你想要移除的代码都包含在条件内部。</p><hr><p>为了保证一切按计划运行，你的打包工具需要替换 <code>process.env.NODE_ENV</code>，而且它需要知道你<strong>想要</strong>在哪种模式下构建项目。</p><p>在几年前，忘记配置环境变量非常常见。你会经常发现在开发模式下的项目被部署到了线上。</p><p>那很糟糕，因为这会使网站加载运行的速度很慢。</p><p>在过去的两年里，这种情况有了显著的改善。例如，webpack 增加了一个简单的 <code>mode</code> 选项，替换了原先手动更改 <code>process.env.NODE_ENV</code>。 React DevTools 现在也会针对开发模式下的站点展示一个红色的 icon，来使得它容易被<a href="https://mobile.twitter.com/BestBuySupport/status/1027195363713736704" target="_blank" rel="noopener">察觉</a>。</p><p><a href="https://overreacted.io/static/ca1c0db064f73cc5c8e21ad605eaba26/d9514/devmode.png" target="_blank" rel="noopener"><img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb8cba8fbc882d?w=590&h=197&f=png&s=20081" alt="React DevTools 的开发模式警告"></a></p><p>一些会帮你做预设置的安装工具比如 Create React App、Next/Nuxt、Vue CLI、Gatsby 等等，会把开发和线上构建分成两个独立的命令，来使得犯错的几率更小。(例如，<code>npm start</code> 和 <code>npm run build</code>。）也就是说，只有线上的构建代码才能被部署，所以开发者再也不可能犯这种错误了。</p><p>一直有一个在讨论的点是，把<strong>线上</strong>模式置为默认，开发模式变为可选项。个人来说，我认为这样做不是很好。从开发模式的警告中受益的人大多是刚刚接触这个框架的开发者。 <strong>他们不会意识到要打开开发模式的开关</strong>，这样就会错过很多应该被警告提前发现的 bug。</p><p>是的，性能问题非常糟糕，但充斥着 bug 的用户体验也是一样。例如，<a href="https://reactjs.org/docs/lists-and-keys.html#keys" target="_blank" rel="noopener">React key 警告</a> 帮助防止发生像发错了消息或者买错了产品这样的 bug。如果在开发中禁用这个警告，对你<strong>和</strong>你的用户来说都是非常冒险的。因为如果它默认是关闭状态，而之后你发现了这个开关并把它打开了，你会发现有太多的警告需要清理。所以大多数人会再把它关上。所以这就是为什么它需要在开始时候就是打开状态，而不是之后才让它生效的原因。</p><p>最后，就算在开发中这些警告是可选项，并且开发者们也<strong>知道</strong>需要在开发的早期就把它们打开，我们还是要回到最开始的问题。还是会有一些开发者不小心把他们部署到线上环境中！</p><p>我们回到这一点来。</p><p>个人认为，我坚信<strong>工具展示和使用的正确模式取决于你是在调试还是在部署</strong>。几乎所有其他环境（无论是手机、桌面还是服务端）除了页面浏览器之外都已经有区分和加载不同的开发和线上环境的方法存在长达数十年了。</p><p>不能仅依靠框架提出或者依赖临时公约，可能 JavaScript 的环境是时候把这种区别作为一个很重要的需求来看待了。</p><hr><p>大道理已经够了！</p><p>让我们再来看一眼代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  doSomethingDev();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  doSomethingProd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能想知道：如果在前端代码中不存在 <code>process</code> 对象，为什么像 React 和 Vue 这样的框架会在 npm 包中依赖它？</p><p><strong>（再次声明：用 <code>&lt;script&gt;</code> 标签可以使用 React 和 Vue 提供的方式把它们加载到浏览器中，这不会依赖 process。取而代之的是，你必须要手动选择，在开发模式下的 <code>.js</code> 还是线上环境中的 <code>.min.js</code> 文件。下面的部分只是关于使用打包工具把 React 或者 Vue 从 npm 中 <code>import</code> 进来而使用它们。）</strong></p><p>像编程中的很多问题一样，这种特殊的约定大多是历史原因。我们还在使用它的原因是因为，它现在已经被很多其他的工具所接受并适应了。换成其他的会有很大的代价，并且不是特别值得这么做。</p><p>所以背后的历史原因究竟是什么？</p><p>在 <code>import</code> 和 <code>export</code> 的语法被标准化的很多年前，有很多方式来表达模块之间的关系。比如 Node.js 中所受欢迎的 <code>require()</code> 和 <code>module.exports</code>，也就是著名的 <a href="https://en.wikipedia.org/wiki/CommonJS" target="_blank" rel="noopener">CommonJS</a>。</p><p>在 npm 上注册发布的代码早期多数是针对 Node.js 写的 <a href="https://expressjs.com" target="_blank" rel="noopener">Express</a> 曾是（可能现在还是？）最受欢迎的服务端 Node.js 框架，它<a href="https://expressjs.com/en/advanced/best-practice-performance.html#set-node_env-to-production" target="_blank" rel="noopener">使用 <code>NODE_ENV</code> 这个环境变量</a> 来使线上模式生效。 一些其他的 npm 包也采用了同样的约定。</p><p>早期的 JavaScript 打包工具比如 browserify 想要在前端工程中使用 npm 中的代码。（是的，<a href="https://blog.npmjs.org/post/101775448305/npm-and-front-end-packaging" target="_blank" rel="noopener">那时候</a> 在前端中几乎没人使用 npm！你可以想象吗？）所以它们拓展了当时在 Node.js 生态系统中的约定，将之应用于前端代码中。</p><p>最初的 “envify” 变革是在 <a href="https://github.com/hughsk/envify/commit/ae8aa26b759cd2115eccbed96f70e7bbdceded97" target="_blank" rel="noopener">2013 正式版</a>。React 就是在差不多那个时候开源的，并且在那个时代 npm 和 browserify 看起来是是打包前端 CommonJS 代码的最佳解决方案。</p><p>React 在很早的时候就提供 npm 版本（还有 <code>&lt;script&gt;</code> 标签版本）。随着 React 变得流行起来，使用 CommonJS 模块来写 JavaScript 的模块化代码、并使用 npm 来管理发布代码也变成了最佳实践。</p><p>React 需要在线上环境移除只应该出现在开发模式中的代码。刚好 Browserify 已经针对这个问题提供了解决方案，所以 React 针对 npm 版本也接受了使用 <code>process.env.NODE_ENV</code> 的这个约定，随着时间的流逝，一些其他的工具和框架，包括 webpack 和 Vue，也采取了相同的措施。</p><p>到了 2019 年时，browserify 已经失去了很大一部分的市场占有率。然而，在构建的阶段把 <code>process.env.NODE_ENV</code> 替换成 <code>&#39;development&#39;</code> 或者 <code>&#39;production&#39;</code> 的这项约定，却一如既往的流行。</p><p><strong>（同样有趣的是，了解 ES 模块的方式是如何一步步发展成作为线上的分发引用模式，而不仅仅只是在开发时使用的发展历史，它是如何慢慢改变天平的？在 Twitter 上告诉我）</strong></p><hr><p>另一件你可能会感到迷惑的事是，在 GitHub 上 React <strong>源码</strong>中，你会看到 <code>__DEV__</code> 被作为一个神奇的变量来使用。但是在 npm 上的 React 代码里，使用的却是 <code>process.env.NODE_ENV</code>。这是怎么做到的？</p><p>从历史上说，我们在源码中使用 <code>__DEV__</code> 来匹配 Facebook 的源码。在很长一段时间里，React 被直接复制进 Facebook 的代码仓库里，所以它需要遵守相同的规则。对于 npm 的代码，我们有一个构建阶段，在发布代码之前会检查并使用 <code>process.env.NODE_ENV !== &#39;production&#39;</code> 来字面地替换 <code>__DEV__</code> 。</p><p>这有时会有一个问题。某些时候，遵循 Node.js 约定的代码在 npm 上运行的很好，但是会破坏 Facebook，反之亦然。</p><p>从 React 16 起，我们改变了这种方式。取而代之，现在我们会针对每一个环境<a href="https://reactjs.org/blog/2017/12/15/improving-the-repository-infrastructure.html#compiling-flat-bundles" target="_blank" rel="noopener">编译一个包</a>（包括 <code>&lt;script&gt;</code> 标签、npm 和 Facebook 内部的代码仓库）。所以甚至是 npm 的 CommonJS 代码也被提前编译成独立的开发和线上包。</p><p>这意味着当 React 源码中出现 <code>if (__DEV__)</code> 的时候，事实上我们会对每一个包产出<strong>两个</strong>代码块。一个被预编译为 <code>__DEV__ = true</code> 另一个是 <code>__DEV__ = false</code>。每一个 npm 包的入口来“决定”该导出哪一个。</p><p><a href="https://unpkg.com/browse/react@16.8.6/index.js" target="_blank" rel="noopener">例如：</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'./cjs/react.production.min.js'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'./cjs/react.development.js'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是你的打包工具把 <code>&#39;development&#39;</code> 或者 <code>&#39;production&#39;</code> 替换为字符串的唯一地方。也是你的压缩工具除去只应在开发环境中 <code>require</code> 代码的唯一地方。</p><p><code>react.production.min.js</code> 和 <code>react.development.js</code> 不再有任何 <code>process.env.NODE_ENV</code> 检查了。这很有意义，因为<strong>当代码真正运行在 Node.js 中的时候</strong>， 访问 <code>process.env</code> <a href="https://reactjs.org/blog/2017/09/26/react-v16.0.html#better-server-side-rendering" target="_blank" rel="noopener">有可能会很慢</a>。提前编译两个模式下的代码包也可以帮助我们优化文件的大小变得<a href="https://reactjs.org/blog/2017/09/26/react-v16.0.html#reduced-file-size" target="_blank" rel="noopener">更加一致</a>，无论你使用的是哪个打包压缩工具。</p><p>这就是它的工作原理！</p><hr><p>我希望有一个更好的方法而不是依赖约定，但是我们已经到这了。如果在所有的 JavaScript 环境中，模式是一个非常重要的概念，并且如果有什么方法能够在浏览器层面来展示这些本不该出现的运行在开发环境下的代码，那就非常棒了。</p><p>另一方面，在单个项目中的约定可以传播到整个生态系统，这点非常神奇。2010 年 <code>EXPRESS_ENV</code> <a href="https://github.com/expressjs/express/commit/03b56d8140dc5c2b574d410bfeb63517a0430451" target="_blank" rel="noopener">变成了 <code>NODE_ENV</code></a> 并在 2013 年<a href="https://github.com/hughsk/envify/commit/ae8aa26b759cd2115eccbed96f70e7bbdceded97" target="_blank" rel="noopener">蔓延到前端</a>。可能这个解决方案并不完美，但是对每一个项目来说，接受它的成本远比说服其他每一个人去做一些改变的成本要低得多。这教会了我们宝贵的一课，关于自上而下与自下而上的方案接受。理解了相比于那些失败的标准来说它是如何一步步地转变成功的标准的。</p><p>隔离开发和线上模式是一个非常有用的技术。我建议你在你的库和应用中使用这项技术，来做一些在线上环境很重，但是在开发环境中却非常有用（通常是严格的）的校验和检查。</p><p>和任何功能强大的特性一样，有些情况下你可能也会滥用它。这是我下一篇文章的话题！</p><blockquote><p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im" target="_blank" rel="noopener">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android" target="_blank" rel="noopener">Android</a>、<a href="https://github.com/xitu/gold-miner#ios" target="_blank" rel="noopener">iOS</a>、<a href="https://github.com/xitu/gold-miner#前端" target="_blank" rel="noopener">前端</a>、<a href="https://github.com/xitu/gold-miner#后端" target="_blank" rel="noopener">后端</a>、<a href="https://github.com/xitu/gold-miner#区块链" target="_blank" rel="noopener">区块链</a>、<a href="https://github.com/xitu/gold-miner#产品" target="_blank" rel="noopener">产品</a>、<a href="https://github.com/xitu/gold-miner#设计" target="_blank" rel="noopener">设计</a>、<a href="https://github.com/xitu/gold-miner#人工智能" target="_blank" rel="noopener">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi" target="_blank" rel="noopener">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi" target="_blank" rel="noopener">知乎专栏</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「使用 React Hook 来检查网络连接状态」</title>
      <link href="/2019/10/24/%E7%BF%BB%E8%AF%91/%E4%BD%BF%E7%94%A8%20React%20Hook%20%E6%A3%80%E6%9F%A5%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81/"/>
      <url>/2019/10/24/%E7%BF%BB%E8%AF%91/%E4%BD%BF%E7%94%A8%20React%20Hook%20%E6%A3%80%E6%9F%A5%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="https://medium.com/the-non-traditional-developer/checking-the-network-connection-with-a-react-hook-ec3d8e4de4ec" target="_blank" rel="noopener">使用 React Hook 来检查网络连接状态</a></li><li>原文作者：<a href="https://medium.com/@want2code" target="_blank" rel="noopener">Justin Travis Waith-Mair</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/checking-the-network-connection-with-a-react-hook.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/checking-the-network-connection-with-a-react-hook.md</a></li><li>译者：<a href="https://github.com/Jerry-FD" target="_blank" rel="noopener">Jerry-FD</a></li><li>校对者：<a href="https://github.com/TiaossuP" target="_blank" rel="noopener">TiaossuP</a>、<a href="https://github.com/Stevens1995" target="_blank" rel="noopener">Stevens1995</a></li></ul></blockquote><h1 id="使用-React-Hook-来检查网络连接状态"><a href="#使用-React-Hook-来检查网络连接状态" class="headerlink" title="使用 React Hook 来检查网络连接状态"></a>使用 React Hook 来检查网络连接状态</h1><p><img src="https://miro.medium.com/max/6646/0*kVB651dEu92o-J-l" alt="拍摄来自 [NASA](https://unsplash.com/@nasa?utm_source=medium&amp;utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&amp;utm_medium=referral)"></p><p>前端开发是一项包含诸多挑战的工作。这项有趣的工作诞生于这个充满设计、用户体验和工程学的世界。我们作为前端开发者的工作是要运用设计、UX 和 UI 逻辑来给用户“打造”一个舒适的体验。</p><p>随着高速专用网络变得越来越普及，网络的正常连接已经习以为常了，但是有一个经常被忽视的问题，当你的用户失去网络连接的时候，你会怎么做，你会给用户什么样的体验。许多时候，我们认为保证网络连接是理所当然的，但现实却并不总是这样。越来越多的页面是由移动设备所展示的，这种网络可不能说是稳定的。Wifi 确实越来普及了，但是 Wifi 的死区也的确存在。就算是物理连接的网线也有可能会被踢掉而失去连接。</p><p>这篇文章的重点不是要深入到 UI/UX 中去讨论当用户丢失连接时怎么做才是最佳实践，相反，我是要帮你越过最大的障碍：在 React Component 的环境里，准确地判断你是否处于网络连接状态。</p><p>##Navigator 对象</p><p>我认为在我们深入了解怎么使用 hook 来实现这个具体功能之前，先来了解 JavaScript 是如何判定当前是否处于有网络的状态非常有意义。这个信息可以通过 Navigator 对象找到。那么什么是 Navigator 对象？可以简单的把它当做是一个只可读取的数据，它根据你的数据，包含当前浏览器的状态和特性。它有定位、userAgent 和一些其他的属性，其中就包括你当前是否处于网络连接状态。和往常一样，我建议你在 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator" target="_blank" rel="noopener">MDN 上查阅关于 Navigator 对象的文档</a>。</p><p>你可以从全局的 window 对象上获取 Navigator 对象：<code>window.navigator</code> 从这里你可以随之获得其中存在的一项或多项属性。我们想要获取的是 <code>onLine</code> 这个属性。这里我特别强调一下。它不是 online，它是驼峰命名的，onLine。</p><h2 id="在-Hook-中使用"><a href="#在-Hook-中使用" class="headerlink" title="在 Hook 中使用"></a>在 Hook 中使用</h2><p>显然我们的首要任务是需要一些状态来跟踪记录我们是否在线的状态以及把它从我们的自定义 hook 中 return 出来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useNetwork</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isOnline, setOnline] = useState(<span class="built_in">window</span>.navigator.onLine);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isOnline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当组件正常挂载时这样做没有问题，但是如果当用户在渲染完成之后掉线我们该怎么做呢？幸运的是，我们可以监听两个事件，触发时以更新状态。为了达到这个效果我们需要使用 useEffect hook：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useNetwork</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isOnline, setNetwork] = useState(<span class="built_in">window</span>.navigator.onLine);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'offline'</span>, () =&gt; setNetwork(<span class="built_in">window</span>.navigator.onLine));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'online'</span>, () =&gt; setNetwork(<span class="built_in">window</span>.navigator.onLine));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isOnline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所见我们监听了两个事件，<code>offline</code> 和 <code>online</code> ，当事件触发的时候随之更新状态。处理过 hooks 和事件监听的同学会立刻注意到两个问题。首先是我们需要从这个 useEffect 回调函数中 return 一个清理函数，这样的话 React 可以帮助我们移除事件的监听。</p><p>其次是想要依次移除事件的监听，你需要提供同一个函数，这样它才能明确哪一个监听器应该被移除。传入另一个看起来一样的箭头函数不会如期移除事件监听，就算这些监听函数‘长得一样’、‘功能一样‘也不行。所以下面是我们更新后的 hook：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useNetwork</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isOnline, setNetwork] = useState(<span class="built_in">window</span>.navigator.onLine);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> updateNetwork = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setNetwork(<span class="built_in">window</span>.navigator.onLine);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'offline'</span>, updateNetwork);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'online'</span>, updateNetwork);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.removeEventListener(<span class="string">'offline'</span>, updateNetwork);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">window</span>.removeEventListener(<span class="string">'online'</span>, updateNetwork);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isOnline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在把函数保存在了变量里面，以此我们可以深入监听和解绑。现在我们已经准备好根据用户是否在线的状态来为用户打造一个独特的体验了。</p><blockquote><p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im" target="_blank" rel="noopener">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android" target="_blank" rel="noopener">Android</a>、<a href="https://github.com/xitu/gold-miner#ios" target="_blank" rel="noopener">iOS</a>、<a href="https://github.com/xitu/gold-miner#前端" target="_blank" rel="noopener">前端</a>、<a href="https://github.com/xitu/gold-miner#后端" target="_blank" rel="noopener">后端</a>、<a href="https://github.com/xitu/gold-miner#区块链" target="_blank" rel="noopener">区块链</a>、<a href="https://github.com/xitu/gold-miner#产品" target="_blank" rel="noopener">产品</a>、<a href="https://github.com/xitu/gold-miner#设计" target="_blank" rel="noopener">设计</a>、<a href="https://github.com/xitu/gold-miner#人工智能" target="_blank" rel="noopener">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi" target="_blank" rel="noopener">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi" target="_blank" rel="noopener">知乎专栏</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「如何用 React Hooks 打造一个不到 100 行代码的异步表单校验库」</title>
      <link href="/2019/10/24/%E7%BF%BB%E8%AF%91/%E5%A6%82%E4%BD%95%E7%94%A8%20React%20Hooks%20%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%88%B0%20100%20%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%9A%84%E5%BC%82%E6%AD%A5%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C%E5%BA%93/"/>
      <url>/2019/10/24/%E7%BF%BB%E8%AF%91/%E5%A6%82%E4%BD%95%E7%94%A8%20React%20Hooks%20%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%88%B0%20100%20%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%9A%84%E5%BC%82%E6%AD%A5%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="https://medium.freecodecamp.org/how-i-built-an-async-form-validation-library-in-100-lines-of-code-with-react-hooks-81dbff6c4a04" target="_blank" rel="noopener">How I built an async form validation library in ~100 lines of code with React Hooks</a></li><li>原文作者：<a href="https://medium.com/@austinmalerba" target="_blank" rel="noopener">Austin Malerba</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/how-i-built-an-async-form-validation-library-in-100-lines-of-code-with-react-hooks.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/how-i-built-an-async-form-validation-library-in-100-lines-of-code-with-react-hooks.md</a></li><li>译者：<a href="https://github.com/Jerry-FD" target="_blank" rel="noopener">Jerry-FD</a></li><li>校对者：<a href="https://github.com/yoyoyohamapi" target="_blank" rel="noopener">yoyoyohamapi</a>，<a href="https://github.com/Xuyuey" target="_blank" rel="noopener">Xuyuey</a>，<a href="https://github.com/xiaonizi1994" target="_blank" rel="noopener">xiaonizi1994</a></li></ul></blockquote><p><img src="https://user-gold-cdn.xitu.io/2019/6/3/16b1c95bb4f07fde?w=1353&h=709&f=png&s=447565" alt></p><p>表单校验是一件很棘手的事情。深入了解表单的实现之后，你会发现有大量的边界场景要处理。幸运的是，市面上有很多表单校验库，它们提供了必要的表计量（译注：如 dirty、invalid、inItialized、pristine 等等）和处理函数，来让我们实现一个健壮的表单。但我要使用 <a href="https://reactjs.org/docs/hooks-reference.html" target="_blank" rel="noopener">React Hooks API</a> 来打造一个 100 行代码以下的表单校验库来挑战自我。虽然 React Hooks 还在实验性阶段，但是这是一个 React Hooks 实现表单校验的证明。</p><p>我要声明的是，我写的这个<strong>库</strong>确实是不到 100 行代码。但这个教程却有 200 行左右的代码，是因为我需要阐释清楚这个库是如何使用的。</p><p>我看过的大多数表单库的新手教程都离不开三个核心话题：<strong>异步校验</strong>，表单联动：某些表单项的校验需要在<strong>其他表单项改变时</strong>触发，<strong>表单校验效率</strong>的优化。我非常反感那些教程把使用场景固定，而忽略其他可变因素的影响的做法。因为在真实场景中往往事与愿违，所以我的教程会尽量覆盖更多真实场景。</p><p>我们的目标需要满足：</p><ul><li><p>同步校验单个表单项，包括当表单项的值发生变化时，会跟随变化的有依赖的表单项</p></li><li><p>异步校验单个表单项，包括当表单项的值发生变化时，会跟随变化的有依赖的表单项</p></li><li><p>在提交表单前，同步校验所有表单项</p></li><li><p>在提交表单前，异步校验所有表单项</p></li><li><p>尝试异步提交，如果表单提交失败，展示返回的错误信息</p></li><li><p>给开发者提供校验表单的函数，让开发者能够在合适的时机，比如 onBlur 的时候校验表单</p></li><li><p>允许单个表单项的多重校验</p></li><li><p>当表单校验未通过时禁止提交</p></li><li><p>表单的错误信息只在有错误信息变化或者尝试提交表单的时候才展示出来</p></li></ul><p>我们将会通过实现一个包含用户名，密码，密码二次确认的账户注册表单来覆盖这些场景。下面是个简单的界面，我们来一起打造这个库吧。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> form = useForm(&#123;</span><br><span class="line">  onSubmit,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> usernameField = useField(<span class="string">"username"</span>, form, &#123;</span><br><span class="line">  defaultValue: <span class="string">""</span>,</span><br><span class="line">  validations: [</span><br><span class="line">    <span class="keyword">async</span> formData =&gt; &#123;</span><br><span class="line">      <span class="keyword">await</span> timeout(<span class="number">2000</span>);</span><br><span class="line">      <span class="keyword">return</span> formData.username.length &lt; <span class="number">6</span> &amp;&amp; <span class="string">"Username already exists"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  fieldsToValidateOnChange: []</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> passwordField = useField(<span class="string">"password"</span>, form, &#123;</span><br><span class="line">  defaultValue: <span class="string">""</span>,</span><br><span class="line">  validations: [</span><br><span class="line">    formData =&gt;</span><br><span class="line">      formData.password.length &lt; <span class="number">6</span> &amp;&amp; <span class="string">"Password must be at least 6 characters"</span></span><br><span class="line">  ],</span><br><span class="line">  fieldsToValidateOnChange: [<span class="string">"password"</span>, <span class="string">"confirmPassword"</span>]</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> confirmPasswordField = useField(<span class="string">"confirmPassword"</span>, form, &#123;</span><br><span class="line">  defaultValue: <span class="string">""</span>,</span><br><span class="line">  validations: [</span><br><span class="line">    formData =&gt;</span><br><span class="line">      formData.password !== formData.confirmPassword &amp;&amp;</span><br><span class="line">      <span class="string">"Passwords do not match"</span></span><br><span class="line">  ],</span><br><span class="line">  fieldsToValidateOnChange: [<span class="string">"password"</span>, <span class="string">"confirmPassword"</span>]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// const &#123; onSubmit, getFormData, addField, isValid, validateFields, submitted, submitting &#125; = form</span></span><br><span class="line"><span class="comment">// const &#123; name, value, onChange, errors, setErrors, pristine, validate, validating &#125; = usernameField</span></span><br></pre></td></tr></table></figure><p>这是一个非常简单的 API，但着实给了我们很大的灵活性。你可能已经意识到了，这个接口包含两个名字很像的函数, validation 和 validate。validation 被定义成一个函数，它以表单数据和表单项的 name 为参数，如果验证出了问题，则返回一个错误信息，与此同时它会返回一个虚值（译者注：可转换为 false 的值）。另一方面，validate 函数会执行这个表单项的所有 validation 函数，并且更新这个表单项的错误列表。</p><p>重中之重，我们需要一个来处理表单值的变化和表单提交的骨架。我们的第一次尝试不会包含任何校验，它仅仅用来处理表单的状态。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳过样板代码: imports, ReactDOM, 等等.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useField = <span class="function">(<span class="params">name, form, &#123; defaultValue &#125; = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> [value, setValue] = useState(defaultValue);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> field = &#123;</span><br><span class="line">    name,</span><br><span class="line">    value,</span><br><span class="line">    onChange: <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      setValue(e.target.value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 注册表单项</span></span><br><span class="line">  form.addField(field);</span><br><span class="line">  <span class="keyword">return</span> field;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useForm = <span class="function">(<span class="params">&#123; onSubmit &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> fields = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getFormData = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获得一个包含原始表单数据的 object</span></span><br><span class="line">    <span class="keyword">return</span> fields.reduce(<span class="function">(<span class="params">formData, field</span>) =&gt;</span> &#123;</span><br><span class="line">      formData[field.name] = field.value;</span><br><span class="line">      <span class="keyword">return</span> formData;</span><br><span class="line">    &#125;, &#123;&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    onSubmit: <span class="keyword">async</span> e =&gt; &#123;</span><br><span class="line">      e.preventDefault(); <span class="comment">// 阻止默认表单提交</span></span><br><span class="line">      <span class="keyword">return</span> onSubmit(getFormData());</span><br><span class="line">    &#125;,</span><br><span class="line">    addField: <span class="function"><span class="params">field</span> =&gt;</span> fields.push(field),</span><br><span class="line">    getFormData</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Field = <span class="function">(<span class="params">&#123; label, name, value, onChange, ...other &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;FormControl className=<span class="string">"field"</span>&gt;</span><br><span class="line">      &lt;InputLabel htmlFor=&#123;name&#125;&gt;&#123;label&#125;&lt;<span class="regexp">/InputLabel&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Input value=&#123;value&#125; onChange=&#123;onChange&#125; &#123;...other&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/FormControl&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const App = props =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const form = useForm(&#123;</span></span><br><span class="line"><span class="regexp">    onSubmit: async formData =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      window.alert("Account created!");</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  const usernameField = useField("username", form, &#123;</span></span><br><span class="line"><span class="regexp">    defaultValue: ""</span></span><br><span class="line"><span class="regexp">  &#125;);</span></span><br><span class="line"><span class="regexp">  const passwordField = useField("password", form, &#123;</span></span><br><span class="line"><span class="regexp">    defaultValue: ""</span></span><br><span class="line"><span class="regexp">  &#125;);</span></span><br><span class="line"><span class="regexp">  const confirmPasswordField = useField("confirmPassword", form, &#123;</span></span><br><span class="line"><span class="regexp">    defaultValue: ""</span></span><br><span class="line"><span class="regexp">  &#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div id="form-container"&gt;</span></span><br><span class="line"><span class="regexp">      &lt;form onSubmit=&#123;form.onSubmit&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Field &#123;...usernameField&#125; label="Username" /</span>&gt;</span><br><span class="line">        &lt;Field &#123;...passwordField&#125; label=<span class="string">"Password"</span> type=<span class="string">"password"</span> /&gt;</span><br><span class="line">        &lt;Field &#123;...confirmPasswordField&#125; label=<span class="string">"Confirm Password"</span> type=<span class="string">"password"</span> /&gt;</span><br><span class="line">        &lt;Button type=<span class="string">"submit"</span>&gt;Submit&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p>这里没有太难理解的代码。表单的值是我们唯一所关心的。每个表单项在它初始化结束之前把自身注册在表单上。我们的 onChange 函数也很简单。这里最复杂的函数就是 getFormData，即便如此，这也无法跟抽象的 reduce 语法相比。getFormData 遍历所有表单项，并返回一个 plain object 来表示表单的值。最后值得一提的就是在表单提交的时候，我们需要调用 preventDefault 来阻止页面重新加载。</p><p>事情发展的很顺利，现在我们来把验证加上吧。当表单项的值发生变化或者提交表单的时候，我们不是指明哪些具体的表单项需要被校验，而是校验所有的表单项。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useField = (</span><br><span class="line">  name,</span><br><span class="line">  form,</span><br><span class="line">  &#123; defaultValue, validations = [] &#125; = &#123;&#125;</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> [value, setValue] = useState(defaultValue);</span><br><span class="line">  <span class="keyword">let</span> [errors, setErrors] = useState([]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> validate = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> formData = form.getFormData();</span><br><span class="line">    <span class="keyword">let</span> errorMessages = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">      validations.map(<span class="function"><span class="params">validation</span> =&gt;</span> validation(formData, name))</span><br><span class="line">    );</span><br><span class="line">    errorMessages = errorMessages.filter(<span class="function"><span class="params">errorMsg</span> =&gt;</span> !!errorMsg);</span><br><span class="line">    setErrors(errorMessages);</span><br><span class="line">    <span class="keyword">let</span> fieldValid = errorMessages.length === <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fieldValid;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  useEffect(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      form.validateFields(); <span class="comment">// 当 value 变化的时候校验表单项</span></span><br><span class="line">    &#125;,</span><br><span class="line">    [value]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> field = &#123;</span><br><span class="line">    name,</span><br><span class="line">    value,</span><br><span class="line">    errors,</span><br><span class="line">    validate,</span><br><span class="line">    setErrors,</span><br><span class="line">    onChange: <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      setValue(e.target.value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 注册表单项</span></span><br><span class="line">  form.addField(field);</span><br><span class="line">  <span class="keyword">return</span> field;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useForm = <span class="function">(<span class="params">&#123; onSubmit &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> fields = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getFormData = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获得一个 object 包含原始表单数据</span></span><br><span class="line">    <span class="keyword">return</span> fields.reduce(<span class="function">(<span class="params">formData, field</span>) =&gt;</span> &#123;</span><br><span class="line">      formData[field.name] = field.value;</span><br><span class="line">      <span class="keyword">return</span> formData;</span><br><span class="line">    &#125;, &#123;&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> validateFields = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> fieldsToValidate = fields;</span><br><span class="line">    <span class="keyword">let</span> fieldsValid = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">      fieldsToValidate.map(<span class="function"><span class="params">field</span> =&gt;</span> field.validate())</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> formValid = fieldsValid.every(<span class="function"><span class="params">isValid</span> =&gt;</span> isValid === <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> formValid;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    onSubmit: <span class="keyword">async</span> e =&gt; &#123;</span><br><span class="line">      e.preventDefault(); <span class="comment">// 阻止表单提交默认事件</span></span><br><span class="line">      <span class="keyword">let</span> formValid = <span class="keyword">await</span> validateFields();</span><br><span class="line">      <span class="keyword">return</span> onSubmit(getFormData(), formValid);</span><br><span class="line">    &#125;,</span><br><span class="line">    addField: <span class="function"><span class="params">field</span> =&gt;</span> fields.push(field),</span><br><span class="line">    getFormData,</span><br><span class="line">    validateFields</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Field = (&#123;</span><br><span class="line">  label,</span><br><span class="line">  name,</span><br><span class="line">  value,</span><br><span class="line">  onChange,</span><br><span class="line">  errors,</span><br><span class="line">  setErrors,</span><br><span class="line">  validate,</span><br><span class="line">  ...other</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> showErrors = !!errors.length;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;FormControl className=<span class="string">"field"</span> error=&#123;showErrors&#125;&gt;</span><br><span class="line">      &lt;InputLabel htmlFor=&#123;name&#125;&gt;&#123;label&#125;&lt;<span class="regexp">/InputLabel&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Input</span></span><br><span class="line"><span class="regexp">        id=&#123;name&#125;</span></span><br><span class="line"><span class="regexp">        value=&#123;value&#125;</span></span><br><span class="line"><span class="regexp">        onChange=&#123;onChange&#125;</span></span><br><span class="line"><span class="regexp">        onBlur=&#123;validate&#125;</span></span><br><span class="line"><span class="regexp">        &#123;...other&#125;</span></span><br><span class="line"><span class="regexp">      /</span>&gt;</span><br><span class="line">      &lt;FormHelperText component=<span class="string">"div"</span>&gt;</span><br><span class="line">        &#123;showErrors &amp;&amp;</span><br><span class="line">          errors.map(<span class="function"><span class="params">errorMsg</span> =&gt;</span> &lt;div key=&#123;errorMsg&#125;&gt;&#123;errorMsg&#125;&lt;/div&gt;)&#125;</span><br><span class="line">      &lt;<span class="regexp">/FormHelperText&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>FormControl&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> form = useForm(&#123;</span><br><span class="line">    onSubmit: <span class="keyword">async</span> formData =&gt; &#123;</span><br><span class="line">      <span class="built_in">window</span>.alert(<span class="string">"Account created!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> usernameField = useField(<span class="string">"username"</span>, form, &#123;</span><br><span class="line">    defaultValue: <span class="string">""</span>,</span><br><span class="line">    validations: [</span><br><span class="line">      <span class="keyword">async</span> formData =&gt; &#123;</span><br><span class="line">        <span class="keyword">await</span> timeout(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> formData.username.length &lt; <span class="number">6</span> &amp;&amp; <span class="string">"Username already exists"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> passwordField = useField(<span class="string">"password"</span>, form, &#123;</span><br><span class="line">    defaultValue: <span class="string">""</span>,</span><br><span class="line">    validations: [</span><br><span class="line">      formData =&gt;</span><br><span class="line">        formData.password.length &lt; <span class="number">6</span> &amp;&amp; <span class="string">"Password must be at least 6 characters"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> confirmPasswordField = useField(<span class="string">"confirmPassword"</span>, form, &#123;</span><br><span class="line">    defaultValue: <span class="string">""</span>,</span><br><span class="line">    validations: [</span><br><span class="line">      formData =&gt;</span><br><span class="line">        formData.password !== formData.confirmPassword &amp;&amp;</span><br><span class="line">        <span class="string">"Passwords do not match"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div id=<span class="string">"form-container"</span>&gt;</span><br><span class="line">      &lt;form onSubmit=&#123;form.onSubmit&#125;&gt;</span><br><span class="line">        &lt;Field &#123;...usernameField&#125; label=<span class="string">"Username"</span> /&gt;</span><br><span class="line">        &lt;Field &#123;...passwordField&#125; label=<span class="string">"Password"</span> type=<span class="string">"password"</span> /&gt;</span><br><span class="line">        &lt;Field &#123;...confirmPasswordField&#125; label=<span class="string">"Confirm Password"</span> type=<span class="string">"password"</span> /&gt;</span><br><span class="line">        &lt;Button type=<span class="string">"submit"</span>&gt;Submit&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p>上面的代码是改进版，大体浏览一下似乎可以跑起来了，但是要做到<a href="https://codesandbox.io/s/wy074qmk98?module=%2Fsrc%2FformHooks.js" target="_blank" rel="noopener">交付给用户</a>还远远不够。这个版本丢掉了很多用于隐藏错误信息的标记态（译者注：flag），这些错误信息可能会在不恰当的时机出现。比如在用户还没修改完输入信息的时候，表单就立马校验并展示相应的错误信息了。</p><p>最基本的，我们需要一些基础的标记状态来告知 UI，如果用户没有修改表单项的值，那么就不展示错误信息。再进一步，除了这些基础的，我们还需要一些额外的标记状态。</p><p>我们需要一个标记态来记录用户已经尝试提交表单了，以及一个标记态来记录表单正在提交中或者表单项正在进行异步校验。你可能也想弄清楚我们为什么要在 useEffect 的内部调用 validateFields，而不是在 onChange 里调用。我们需要 useEffect 是因为 setValue 是异步发生的，它既不会返回一个 promise，也不会给我们提供一个 callback。因此，唯一能让我们确定 setValue 是否完成的方法，就是通过 useEffect 来监听值的变化。</p><p>现在我们一起来实现这些所谓的标记态吧。用它们来更好的完善 UI 和细节。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useField = (</span><br><span class="line">  name,</span><br><span class="line">  form,</span><br><span class="line">  &#123; defaultValue, validations = [], fieldsToValidateOnChange = [name] &#125; = &#123;&#125;</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> [value, setValue] = useState(defaultValue);</span><br><span class="line">  <span class="keyword">let</span> [errors, setErrors] = useState([]);</span><br><span class="line">  <span class="keyword">let</span> [pristine, setPristine] = useState(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">let</span> [validating, setValidating] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">let</span> validateCounter = useRef(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> validate = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> validateIteration = ++validateCounter.current;</span><br><span class="line">    setValidating(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">let</span> formData = form.getFormData();</span><br><span class="line">    <span class="keyword">let</span> errorMessages = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">      validations.map(<span class="function"><span class="params">validation</span> =&gt;</span> validation(formData, name))</span><br><span class="line">    );</span><br><span class="line">    errorMessages = errorMessages.filter(<span class="function"><span class="params">errorMsg</span> =&gt;</span> !!errorMsg);</span><br><span class="line">    <span class="keyword">if</span> (validateIteration === validateCounter.current) &#123;</span><br><span class="line">      <span class="comment">// 最近一次调用</span></span><br><span class="line">      setErrors(errorMessages);</span><br><span class="line">      setValidating(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> fieldValid = errorMessages.length === <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fieldValid;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  useEffect(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (pristine) <span class="keyword">return</span>; <span class="comment">// 避免渲染完成后的第一次校验</span></span><br><span class="line">      form.validateFields(fieldsToValidateOnChange);</span><br><span class="line">    &#125;,</span><br><span class="line">    [value]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> field = &#123;</span><br><span class="line">    name,</span><br><span class="line">    value,</span><br><span class="line">    errors,</span><br><span class="line">    setErrors,</span><br><span class="line">    pristine,</span><br><span class="line">    onChange: <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (pristine) &#123;</span><br><span class="line">        setPristine(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      setValue(e.target.value);</span><br><span class="line">    &#125;,</span><br><span class="line">    validate,</span><br><span class="line">    validating</span><br><span class="line">  &#125;;</span><br><span class="line">  form.addField(field);</span><br><span class="line">  <span class="keyword">return</span> field;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useForm = <span class="function">(<span class="params">&#123; onSubmit &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> [submitted, setSubmitted] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">let</span> [submitting, setSubmitting] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">let</span> fields = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> validateFields = <span class="keyword">async</span> fieldNames =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> fieldsToValidate;</span><br><span class="line">    <span class="keyword">if</span> (fieldNames <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">      fieldsToValidate = fields.filter(<span class="function"><span class="params">field</span> =&gt;</span></span><br><span class="line">        fieldNames.includes(field.name)</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果 fieldNames 缺省，则验证所有表单项</span></span><br><span class="line">      fieldsToValidate = fields;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> fieldsValid = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">      fieldsToValidate.map(<span class="function"><span class="params">field</span> =&gt;</span> field.validate())</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> formValid = fieldsValid.every(<span class="function"><span class="params">isValid</span> =&gt;</span> isValid === <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> formValid;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getFormData = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fields.reduce(<span class="function">(<span class="params">formData, f</span>) =&gt;</span> &#123;</span><br><span class="line">      formData[f.name] = f.value;</span><br><span class="line">      <span class="keyword">return</span> formData;</span><br><span class="line">    &#125;, &#123;&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    onSubmit: <span class="keyword">async</span> e =&gt; &#123;</span><br><span class="line">      e.preventDefault();</span><br><span class="line">      setSubmitting(<span class="literal">true</span>);</span><br><span class="line">      setSubmitted(<span class="literal">true</span>); <span class="comment">// 用户已经至少提交过一次表单</span></span><br><span class="line">      <span class="keyword">let</span> formValid = <span class="keyword">await</span> validateFields();</span><br><span class="line">      <span class="keyword">let</span> returnVal = <span class="keyword">await</span> onSubmit(getFormData(), formValid);</span><br><span class="line">      setSubmitting(<span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">return</span> returnVal;</span><br><span class="line">    &#125;,</span><br><span class="line">    isValid: <span class="function"><span class="params">()</span> =&gt;</span> fields.every(<span class="function"><span class="params">f</span> =&gt;</span> f.errors.length === <span class="number">0</span>),</span><br><span class="line">    addField: <span class="function"><span class="params">field</span> =&gt;</span> fields.push(field),</span><br><span class="line">    getFormData,</span><br><span class="line">    validateFields,</span><br><span class="line">    submitted,</span><br><span class="line">    submitting</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Field = (&#123;</span><br><span class="line">  label,</span><br><span class="line">  name,</span><br><span class="line">  value,</span><br><span class="line">  onChange,</span><br><span class="line">  errors,</span><br><span class="line">  setErrors,</span><br><span class="line">  pristine,</span><br><span class="line">  validating,</span><br><span class="line">  validate,</span><br><span class="line">  formSubmitted,</span><br><span class="line">  ...other</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> showErrors = (!pristine || formSubmitted) &amp;&amp; !!errors.length;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;FormControl className=<span class="string">"field"</span> error=&#123;showErrors&#125;&gt;</span><br><span class="line">      &lt;InputLabel htmlFor=&#123;name&#125;&gt;&#123;label&#125;&lt;<span class="regexp">/InputLabel&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Input</span></span><br><span class="line"><span class="regexp">        id=&#123;name&#125;</span></span><br><span class="line"><span class="regexp">        value=&#123;value&#125;</span></span><br><span class="line"><span class="regexp">        onChange=&#123;onChange&#125;</span></span><br><span class="line"><span class="regexp">        onBlur=&#123;() =&gt; !pristine &amp;&amp; validate()&#125;</span></span><br><span class="line"><span class="regexp">        endAdornment=&#123;</span></span><br><span class="line"><span class="regexp">          &lt;InputAdornment position="end"&gt;</span></span><br><span class="line"><span class="regexp">            &#123;validating &amp;&amp; &lt;LoadingIcon className="rotate" /</span>&gt;&#125;</span><br><span class="line">          &lt;<span class="regexp">/InputAdornment&gt;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        &#123;...other&#125;</span></span><br><span class="line"><span class="regexp">      /</span>&gt;</span><br><span class="line">      &lt;FormHelperText component=<span class="string">"div"</span>&gt;</span><br><span class="line">        &#123;showErrors &amp;&amp;</span><br><span class="line">          errors.map(<span class="function"><span class="params">errorMsg</span> =&gt;</span> &lt;div key=&#123;errorMsg&#125;&gt;&#123;errorMsg&#125;&lt;/div&gt;)&#125;</span><br><span class="line">      &lt;<span class="regexp">/FormHelperText&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>FormControl&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> form = useForm(&#123;</span><br><span class="line">    onSubmit: <span class="keyword">async</span> (formData, valid) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!valid) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">await</span> timeout(<span class="number">2000</span>); <span class="comment">// 模拟网络延迟</span></span><br><span class="line">      <span class="keyword">if</span> (formData.username.length &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="comment">//模拟服务端返回 400 </span></span><br><span class="line">        usernameField.setErrors([<span class="string">"Make a longer username"</span>]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//模拟服务端返回 201 </span></span><br><span class="line">        <span class="built_in">window</span>.alert(</span><br><span class="line">          <span class="string">`form valid: <span class="subst">$&#123;valid&#125;</span>, form data: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(formData)&#125;</span>`</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> usernameField = useField(<span class="string">"username"</span>, form, &#123;</span><br><span class="line">    defaultValue: <span class="string">""</span>,</span><br><span class="line">    validations: [</span><br><span class="line">      <span class="keyword">async</span> formData =&gt; &#123;</span><br><span class="line">        <span class="keyword">await</span> timeout(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> formData.username.length &lt; <span class="number">6</span> &amp;&amp; <span class="string">"Username already exists"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    fieldsToValidateOnChange: []</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> passwordField = useField(<span class="string">"password"</span>, form, &#123;</span><br><span class="line">    defaultValue: <span class="string">""</span>,</span><br><span class="line">    validations: [</span><br><span class="line">      formData =&gt;</span><br><span class="line">        formData.password.length &lt; <span class="number">6</span> &amp;&amp; <span class="string">"Password must be at least 6 characters"</span></span><br><span class="line">    ],</span><br><span class="line">    fieldsToValidateOnChange: [<span class="string">"password"</span>, <span class="string">"confirmPassword"</span>]</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> confirmPasswordField = useField(<span class="string">"confirmPassword"</span>, form, &#123;</span><br><span class="line">    defaultValue: <span class="string">""</span>,</span><br><span class="line">    validations: [</span><br><span class="line">      formData =&gt;</span><br><span class="line">        formData.password !== formData.confirmPassword &amp;&amp;</span><br><span class="line">        <span class="string">"Passwords do not match"</span></span><br><span class="line">    ],</span><br><span class="line">    fieldsToValidateOnChange: [<span class="string">"password"</span>, <span class="string">"confirmPassword"</span>]</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> requiredFields = [usernameField, passwordField, confirmPasswordField];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div id=<span class="string">"form-container"</span>&gt;</span><br><span class="line">      &lt;form onSubmit=&#123;form.onSubmit&#125;&gt;</span><br><span class="line">        &lt;Field</span><br><span class="line">          &#123;...usernameField&#125;</span><br><span class="line">          formSubmitted=&#123;form.submitted&#125;</span><br><span class="line">          label=<span class="string">"Username"</span></span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;Field</span><br><span class="line">          &#123;...passwordField&#125;</span><br><span class="line">          formSubmitted=&#123;form.submitted&#125;</span><br><span class="line">          label=<span class="string">"Password"</span></span><br><span class="line">          type=<span class="string">"password"</span></span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;Field</span><br><span class="line">          &#123;...confirmPasswordField&#125;</span><br><span class="line">          formSubmitted=&#123;form.submitted&#125;</span><br><span class="line">          label=<span class="string">"Confirm Password"</span></span><br><span class="line">          type=<span class="string">"password"</span></span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;Button</span><br><span class="line">          type=<span class="string">"submit"</span></span><br><span class="line">          disabled=&#123;</span><br><span class="line">            !form.isValid() ||</span><br><span class="line">            form.submitting ||</span><br><span class="line">            requiredFields.some(<span class="function"><span class="params">f</span> =&gt;</span> f.pristine)</span><br><span class="line">          &#125;</span><br><span class="line">        &gt;</span><br><span class="line">          &#123;form.submitting ? <span class="string">"Submitting"</span> : <span class="string">"Submit"</span>&#125;</span><br><span class="line">        &lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p>最后一次尝试，我们加了很多东西进去。包括四个标记态：pristine、validating、submitted 和 submitting。还添加了 fieldsToValidateOnChange，将它传给 validateFields 来声明当表单的值发生变化的时候哪些表单项需要被校验。我们在 UI 层通过这些标记状态来控制何时展示错误信息和加载动画以及禁用提交按钮。</p><p>你可能注意到了一个很特别的东西 validateCounter。我们需要记录 validate 函数的调用次数，因为 validate 在当前的调用完成之前，它有可能会被再次调用。如果是这种场景的话，我们应该放弃当前调用的结果，而只使用最新一次的调用结果来更新表单项的错误状态。</p><p>一切就绪之后，这就是我们的成果了。</p><ul><li><a href="https://codesandbox.io/embed/x964kxp2vo" target="_blank" rel="noopener">https://codesandbox.io/embed/x964kxp2vo</a></li></ul><p>React Hooks 提供了一个简洁的表单校验解决方案。这是我使用这个 API 的第一次尝试。尽管有一点瑕疵，但是我依然感到了它的强大。这个接口有些奇怪，因为是按照我喜欢的样子来的。然而除了这些瑕疵以外，它的功能还是很强大的。</p><p>我觉得它还少了一些特性，比如一个 callback 机制来表明何时 useState 更新 state 完毕，这也是一个在 useEffect hook 中检查对比 prop 变化的方法。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>为了保证这个教程的易于上手，我刻意省略了一些参数的校验和异常错误处理。比如，我没有校验传入的 form 参数是否真的是一个 form 对象。如果我能明确地校验它的类型并抛出一个详细的异常信息会更好。事实上，我已经写了，代码会像这样报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot read property ‘addField’ of undefined</span><br></pre></td></tr></table></figure><p>在把这份代码发布成 npm 包之前，还需要合适的参数校验和异常错误处理。如我所说，如果你想深入了解的话，我已经用 <a href="https://github.com/ianstormtaylor/superstruct" target="_blank" rel="noopener">superstruct</a> 实现了一个包含参数校验的<a href="https://codesandbox.io/s/1417995kx4" target="_blank" rel="noopener">更健壮的版本</a>。</p><blockquote><p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im" target="_blank" rel="noopener">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android" target="_blank" rel="noopener">Android</a>、<a href="https://github.com/xitu/gold-miner#ios" target="_blank" rel="noopener">iOS</a>、<a href="https://github.com/xitu/gold-miner#前端" target="_blank" rel="noopener">前端</a>、<a href="https://github.com/xitu/gold-miner#后端" target="_blank" rel="noopener">后端</a>、<a href="https://github.com/xitu/gold-miner#区块链" target="_blank" rel="noopener">区块链</a>、<a href="https://github.com/xitu/gold-miner#产品" target="_blank" rel="noopener">产品</a>、<a href="https://github.com/xitu/gold-miner#设计" target="_blank" rel="noopener">设计</a>、<a href="https://github.com/xitu/gold-miner#人工智能" target="_blank" rel="noopener">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi" target="_blank" rel="noopener">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi" target="_blank" rel="noopener">知乎专栏</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「X 为啥不是 Hook？」</title>
      <link href="/2019/10/24/%E7%BF%BB%E8%AF%91/X%20%E4%B8%BA%E5%95%A5%E4%B8%8D%E6%98%AF%20hook%EF%BC%9F/"/>
      <url>/2019/10/24/%E7%BF%BB%E8%AF%91/X%20%E4%B8%BA%E5%95%A5%E4%B8%8D%E6%98%AF%20hook%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="https://overreacted.io/why-isnt-x-a-hook/" target="_blank" rel="noopener">Why Isn’t X a Hook?</a></li><li>原文作者：<a href="https://mobile.twitter.com/dan_abramov" target="_blank" rel="noopener">Dan Abramov</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/why-isnt-x-a-hook.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/why-isnt-x-a-hook.md</a></li><li>译者：<a href="https://github.com/Jerry-FD" target="_blank" rel="noopener">Jerry-FD</a></li><li>校对者：<a href="https://github.com/yoyoyohamapi" target="_blank" rel="noopener">yoyoyohamapi</a>, <a href="https://github.com/CoolRice" target="_blank" rel="noopener">CoolRice</a></li></ul></blockquote><h1 id="X-为啥不是-hook"><a href="#X-为啥不是-hook" class="headerlink" title="X 为啥不是 hook?"></a>X 为啥不是 hook?</h1><blockquote><p>由读者翻译的版本：<a href="https://overreacted.io/es/why-isnt-x-a-hook/" target="_blank" rel="noopener">西班牙语</a></p></blockquote><p>自 <a href="https://reactjs.org/hooks" target="_blank" rel="noopener">React Hooks</a> 第一个 alpha 版本发布以来, 这个问题一直被激烈讨论：“为什么 <strong>API</strong> 不是 hook？”</p><p>你要知道，只有下面这几个<strong>算是</strong> hooks：</p><ul><li><a href="https://reactjs.org/docs/hooks-reference.html#usestate" target="_blank" rel="noopener"><code>useState()</code></a> 用来声明 state 变量</li><li><a href="https://reactjs.org/docs/hooks-reference.html#useeffect" target="_blank" rel="noopener"><code>useEffect()</code></a> 用来声明副作用</li><li><a href="https://reactjs.org/docs/hooks-reference.html#usecontext" target="_blank" rel="noopener"><code>useContext()</code></a> 用来读取一些上下文</li></ul><p>但是像 <code>React.memo()</code> 和 <code>&lt;Context.Provider&gt;</code>，这些 API 它们<strong>不是</strong> Hooks。一般来说，这些 Hook 版本的 API 被认为是 <strong>非组件化</strong> 或 <strong>反模块化</strong> 的。这篇文章将帮助你理解其中的原理。</p><p><strong>注：这篇文章并非教你如何高效的使用 React，而是对 hooks API 饶有兴趣的开发者所准备的深入分析。</strong></p><hr><p>以下两个重要的属性是我们希望 React 的 APIs 应该拥有的：</p><ol><li><p><strong>可组合</strong>：<a href="https://reactjs.org/docs/hooks-custom.html" target="_blank" rel="noopener">Custom Hooks（自定义 Hooks）</a>极大程度上决定了 Hooks API 为何如此好用。我们希望开发者们经常使用自定义 hooks，这样就需要确保不同开发者所写的 hooks <a href="/why-do-hooks-rely-on-call-order/#flaw-4-the-diamond-problem">不会冲突</a>。（撰写干净并且不会相互冲突的组件实在太棒了）</p></li><li><p><strong>可调试</strong>：随着应用的膨胀，我们希望 bug 很<a href="/the-bug-o-notation/">容易被发现</a>。React 最棒的特性之一就是，当你发现某些渲染错误的时候，你可以顺着组件树寻找，直到找出是哪一个组件的 props 或 state 的值导致的错误。</p></li></ol><p>有了这两个约束，我们就知道哪些算是真正意义上的 Hook，而哪些不算。</p><hr><h2 id="一个真正的-Hook-useState"><a href="#一个真正的-Hook-useState" class="headerlink" title="一个真正的 Hook: useState()"></a>一个真正的 Hook: <code>useState()</code></h2><h3 id="可组合"><a href="#可组合" class="headerlink" title="可组合"></a>可组合</h3><p>多个自定义 Hooks 各自调用 <code>useState()</code> 不会冲突：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMyCustomHook1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 无论这里做了什么，它都只会作用在这里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMyCustomHook2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 无论这里做了什么，它都只会作用在这里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  useMyCustomHook1();</span><br><span class="line">  useMyCustomHook2();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无限制的调用一个 <code>useState()</code> 总是安全的。在你声明新的状态量时，你不用理会其他组件用到的 Hooks，也不用担心状态量的更新会相互干扰。</p><p><strong>结论:</strong> ✅ <code>useState()</code> 不会使自定义 Hooks 变得脆弱。</p><h3 id="可调试"><a href="#可调试" class="headerlink" title="可调试"></a>可调试</h3><p>Hooks 非常好用，因为你可以在 Hooks <strong>之间</strong>传值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function useWindowWidth() &#123;</span><br><span class="line">  const [width, setWidth] = useState(window.innerWidth);</span><br><span class="line">  // ...</span><br><span class="line">  return width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function useTheme(isMobile) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Comment() &#123;</span><br><span class="line">  const width = useWindowWidth();</span><br><span class="line">  const isMobile = width &lt; MOBILE_VIEWPORT;</span><br><span class="line">  const theme = useTheme(isMobile);</span><br><span class="line">  return (</span><br><span class="line">    &lt;section className=&#123;theme.comment&#125;&gt;</span><br><span class="line">      &#123;/* ... */&#125;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果我们的代码出错了呢？我们又该怎么调试？</p><p>我们先假设，从 <code>theme.comment</code> 拿到的 CSS 的 class 是错的。我们该怎么调试? 我们可以打一个断点或者在我们的组件体内加一些 log。</p><p>我们可能会发现 <code>theme</code> 是错的，但是 <code>width</code> 和 <code>isMobile</code> 是对的。这会提示我们问题出在 <code>useTheme()</code> 内部。又或许我们发现 <code>width</code> 本身是错的。这可以指引我们去查看 <code>useWindowWidth()</code>。</p><p><strong>简单看一下中间值就能指导我们哪个顶层的 Hooks 有 bug。</strong> 我们不需要挨个去查看他们<strong>所有的</strong>实现。</p><p>这样，我们就能够洞察 bug 所在的部分，几次三番之后，程序问题终得其解。</p><p>如果我们的自定义 Hook 嵌套的层级加深的时候，这一点就显得很重要了。假设一下我们有一个 3 层嵌套的自定义 Hook，每一层级的内部又用了 3 个不同的自定义 Hooks。在 <strong>3 处</strong>找bug和最多 <strong>3 + 3×3 + 3×3×3 = 39 处</strong>找 bug 的<a href="/the-bug-o-notation/">区别</a>是巨大的。幸运的是， <code>useState()</code> 不会魔法般的 “影响” 其他 Hooks 或组件。与任何 <code>useState()</code> 所返回的变量一样，一个可能造成 bug 的返回值也是有迹可循的。</p><p><strong>结论:</strong> ✅ <code>useState()</code> 不会使你的代码逻辑变得模糊不清，我们可以直接沿着面包屑找到 bug。</p><hr><h2 id="它不是一个-Hook-useBailout"><a href="#它不是一个-Hook-useBailout" class="headerlink" title="它不是一个 Hook: useBailout()"></a>它不是一个 Hook: <code>useBailout()</code></h2><p>作为一个优化点，组件使用 Hooks 可以避免重复渲染（re-rendering）。</p><p>其中一个方法是使用 <a href="https://reactjs.org/blog/2018/10/23/react-v-16-6.html#reactmemo" target="_blank" rel="noopener"><code>React.memo()</code></a> 包裹住整个组件。如果 props 和上次渲染完之后对比浅相等（shallowly equal），就可以避免重复渲染。这和 class 模式中的<code>PureComponent</code> 很像。</p><p><code>React.memo()</code> 接受一个组件作为参数，并返回一个组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Button(props) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">export default React.memo(Button);</span><br></pre></td></tr></table></figure><p><strong>但它为什么就不是 Hook？</strong></p><p>不论你叫它 <code>useShouldComponentUpdate()</code>、<code>usePure()</code>、<code>useSkipRender()</code> 还是 <code>useBailout()</code>，它看起来都差不多长这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Button</span>(<span class="params">&#123; color &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ⚠️ 不是真正的 API</span></span><br><span class="line">  useBailout(<span class="function"><span class="params">prevColor</span> =&gt;</span> prevColor !== color, color);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button className=&#123;<span class="string">'button-'</span> + color&#125;&gt;  </span><br><span class="line">      OK</span><br><span class="line">    &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>还有一些其他的变种 (比如：一个简单的 <code>usePure()</code>) 但是大体上来说，他们都有一些相同的缺陷。</p><h3 id="可组合-1"><a href="#可组合-1" class="headerlink" title="可组合"></a>可组合</h3><p>我们来试试把 <code>useBailout()</code> 放在 2 个自定义 Hooks 中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function useFriendStatus(friendID) &#123;</span><br><span class="line">  const [isOnline, setIsOnline] = useState(null);</span><br><span class="line"></span><br><span class="line">  // ⚠️ 不是真正的 API</span><br><span class="line">  useBailout(prevIsOnline =&gt; prevIsOnline !== isOnline, isOnline);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const handleStatusChange = status =&gt; setIsOnline(status.isOnline);</span><br><span class="line">    ChatAPI.subscribe(friendID, handleStatusChange);</span><br><span class="line">    return () =&gt; ChatAPI.unsubscribe(friendID, handleStatusChange);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return isOnline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function useWindowWidth() &#123;</span><br><span class="line">  const [width, setWidth] = useState(window.innerWidth);</span><br><span class="line">  </span><br><span class="line">  // ⚠️ 不是真正的 API</span><br><span class="line">  useBailout(prevWidth =&gt; prevWidth !== width, width);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const handleResize = () =&gt; setWidth(window.innerWidth);</span><br><span class="line">    window.addEventListener(&apos;resize&apos;, handleResize);</span><br><span class="line">    return () =&gt; window.removeEventListener(&apos;resize&apos;, handleResize);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>译注：使用了 <code>useBailout</code> 后，<code>useFriendStatus</code> 只会在 <code>isOnline</code> 状态变化时才允许 re-render，<code>useWindowWidth</code> 只会在 <code>width</code> 变化时才允许 re-render。</p><p>现在如果你在同一个组件中同时用到他们会怎么样呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function ChatThread(&#123; friendID, isTyping &#125;) &#123;</span><br><span class="line">  const width = useWindowWidth();</span><br><span class="line">  const isOnline = useFriendStatus(friendID);</span><br><span class="line">  return (</span><br><span class="line">    &lt;ChatLayout width=&#123;width&#125;&gt;</span><br><span class="line">      &lt;FriendStatus isOnline=&#123;isOnline&#125; /&gt;</span><br><span class="line">      &#123;isTyping &amp;&amp; &apos;Typing...&apos;&#125;</span><br><span class="line">    &lt;/ChatLayout&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么时候会 re-render 呢?</p><p>如果每一个 <code>useBailout()</code> 的调用都有能力跳过这次更新，如果 <code>useFriendStatus()</code> 阻止了 re-render，那么 <code>useWindowWidth</code> 就无法获得更新，反之亦然。<strong>这些 Hooks 会相互阻塞。</strong></p><p>然而，在组件内部，倘若只有所有调用了 <code>useBailout()</code> 都同意不 re-render 组件才不会更新，那么当 props 中的 <code>isTyping</code> 改变时，由于内部所有 <code>useBailout()</code> 调用都没有同意更新，导致 <code>ChatThread</code> 也无法更新。</p><p>基于这种假设，将导致更糟糕的局面，<strong>任何新置入组件的 Hooks</strong> 都需要去调用 <code>useBailout()</code>，不这样做的话，它们就无法投出“反对票”来让自己获得更新。</p><p><strong>结论:</strong> 🔴 <code>useBailout()</code> 破坏了可组合性。添加一个 Hook 会破坏其他 Hooks 的状态更新。我们希望这些 APIs 是<a href="/optimized-for-change/">稳定的</a>，但是这个特性显然是与之相反了。</p><h3 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a>Debugging</h3><p><code>useBailout()</code> 对调试有什么影响呢？</p><p>我们用相同的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChatThread</span>(<span class="params">&#123; friendID, isTyping &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> width = useWindowWidth();</span><br><span class="line">  <span class="keyword">const</span> isOnline = useFriendStatus(friendID);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ChatLayout width=&#123;width&#125;&gt;</span><br><span class="line">      &lt;FriendStatus isOnline=&#123;isOnline&#125; /&gt;</span><br><span class="line">      &#123;isTyping &amp;&amp; <span class="string">'Typing...'</span>&#125;</span><br><span class="line">    &lt;<span class="regexp">/ChatLayout&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>事实上即使 prop 上层的某处改变了，<code>Typing...</code> 这个 label 也不会像我们期望的那样出现。那么我们怎么调试呢？</p><p><strong>一般来说， 在 React 中你可以通过向</strong>上<strong>寻找的办法，自信的回答这个问题。</strong> 如果 <code>ChatThread</code> 没有得到新的 <code>isTyping</code> 的值， 我们可以打开那个渲染 <code>&lt;ChatThread isTyping={myVar} /&gt;</code> 的组件，检查 <code>myVar</code>，诸如此类。 在其中的某一层， 我们会发现要么是容易出错的 <code>shouldComponentUpdate()</code> 跳过了渲染, 要么是一个错误的 <code>isTyping</code> 的值被传递了下来。通常来说查看这条链路上的每个组件，已经足够定位到问题的来源了。</p><p>然而, 假如这个 <code>useBailout()</code> 真是个 Hook，如果你不检查我们在 <code>ChatThread</code> 中用到的<strong>每一个自定义 Hook (深入地)</strong> 和在各自链路上的所有组件，你永远都不会知道跳过这次更新的原因。更因为任何父组件<em>也</em>可能会用到自定义 Hooks， 这个<a href="/the-bug-o-notation/">规模</a>很恐怖。</p><p>这就像你要在抽屉里找一把螺丝刀，而每一层抽屉里都包含一堆小抽屉，你无法想象爱丽丝仙境中的兔子洞有多深。</p><p><strong>结论</strong>：🔴 <code>useBailout()</code> 不仅破坏了可组合性，也极大的增加了调试的步骤和找 bug 过程的认知负担 — 某些时候，是指数级的。</p><hr><p>全文我们探讨了一个真正的 Hook，<code>useState()</code>，和一个不太算是 Hook 的 <code>useBailout()</code>，并从可组合性及可调试性两个方面说明了为什么一个是 Hook，而一个不算是 Hook。</p><p>尽管现在没有 “Hook 版本的 <code>memo()</code> 或 <code>shouldComponentUpdate()</code>，但 React <strong>确实</strong>提供了一个名叫 <a href="https://reactjs.org/docs/hooks-reference.html#usememo" target="_blank" rel="noopener"><code>useMemo()</code></a> 的 Hook。它有类似的作用，但是他的语义不会迷惑使用它的人。</p><p><code>useBailout()</code> 这个例子，描述了控制组件是否 re-render 并不适合做成一个 hook。这里还有一些其他的例子 - 例如，<code>useProvider()</code>， <code>useCatch()</code>，<code>useSuspense()</code>。</p><p>现在你知道为什么某些 API 不算是 Hook 了吗？</p><p><strong>(当你开始迷惑时，就提醒自己：可组合… 可调试)</strong></p><p><a href="https://mobile.twitter.com/search?q=https%3A%2F%2Foverreacted.io%2Fwhy-isnt-x-a-hook%2F" target="_blank" rel="noopener">Discuss on Twitter</a> • <a href="https://github.com/gaearon/overreacted.io/edit/master/src/pages/why-isnt-x-a-hook/index.md" target="_blank" rel="noopener">Edit on GitHub</a></p><blockquote><p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im" target="_blank" rel="noopener">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android" target="_blank" rel="noopener">Android</a>、<a href="https://github.com/xitu/gold-miner#ios" target="_blank" rel="noopener">iOS</a>、<a href="https://github.com/xitu/gold-miner#前端" target="_blank" rel="noopener">前端</a>、<a href="https://github.com/xitu/gold-miner#后端" target="_blank" rel="noopener">后端</a>、<a href="https://github.com/xitu/gold-miner#区块链" target="_blank" rel="noopener">区块链</a>、<a href="https://github.com/xitu/gold-miner#产品" target="_blank" rel="noopener">产品</a>、<a href="https://github.com/xitu/gold-miner#设计" target="_blank" rel="noopener">设计</a>、<a href="https://github.com/xitu/gold-miner#人工智能" target="_blank" rel="noopener">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi" target="_blank" rel="noopener">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi" target="_blank" rel="noopener">知乎专栏</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Google 的 Pagespeed 的工作原理：提升你的页面分数和搜索引擎排名」</title>
      <link href="/2019/10/24/%E7%BF%BB%E8%AF%91/Google%20%E7%9A%84%20Pagespeed%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A%E6%8F%90%E5%8D%87%E4%BD%A0%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%88%86%E6%95%B0%E5%92%8C%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8E%92%E5%90%8D/"/>
      <url>/2019/10/24/%E7%BF%BB%E8%AF%91/Google%20%E7%9A%84%20Pagespeed%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A%E6%8F%90%E5%8D%87%E4%BD%A0%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%88%86%E6%95%B0%E5%92%8C%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8E%92%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="https://calibreapp.com/blog/how-pagespeed-works/" target="_blank" rel="noopener">Google 的 Pagespeed 的工作原理：提升你的分数和搜索引擎排名</a></li><li>原文作者：<a href="https://calibreapp.com/blog/author/ben-schwarz" target="_blank" rel="noopener">Ben Schwarz</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/how-pagespeed-works.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/how-pagespeed-works.md</a></li><li>译者：<a href="https://github.com/Jerry-FD/" target="_blank" rel="noopener">Jerry-FD</a></li><li>校对者：<a href="https://github.com/weberpan/" target="_blank" rel="noopener">weberpan</a>，<a href="https://github.com/Endone/" target="_blank" rel="noopener">Endone</a></li></ul></blockquote><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1d236050678f6?w=2876&h=1644&f=png&s=608633" alt></p><p>通过这篇文章，我们将揭开 PageSpeed 最为重要的页面速度评分的计算方法。</p><p>毫无疑问，页面的加载速度已经成了提升页面收益和降低流失率的关键性因素。由于 Google 已经将页面的加载速度列入影响其搜索排名的因素，现在更多的企业和组织都把目光聚焦在提升页面性能上了。</p><p>去年 <strong>Google 针对他们的搜索排名算法做了两个重大的调整</strong>：</p><ul><li>三月，<a href="https://webmasters.googleblog.com/2018/03/rolling-out-mobile-first-indexing.html" target="_blank" rel="noopener">搜索结果排名以移动端版本的页面为基础</a>，取代之前的桌面端版本。</li><li><a href="https://webmasters.googleblog.com/2018/01/using-page-speed-in-mobile-search.html" target="_blank" rel="noopener">七月，SEO 排名算法</a>更新为，增加页面的加载速度作为影响其搜索排名的因素，如移动端页面排名<a href="https://developers.google.com/web/updates/2018/07/search-ads-speed#the_mobile_speed_score_for_ads_landing_pages" target="_blank" rel="noopener">和广告排名。</a></li></ul><p>通过这些改变，我们可以总结出两个结论：</p><ul><li><strong>手机端页面的加载速度会影响你整站的 SEO 排名。</strong></li><li>如果你的页面加载很慢，就会降低你的广告质量分，进而你的<strong>广告费会更贵。</strong></li></ul><p>Google 道：</p><blockquote><p>更快的加载速度不仅仅会提升我们的体验；最近的数据显示，提升页面的加载速度也会降低操作成本。和我们一样，我们的用户就很重视速度 — 这就是我们决定将页面的速度这一因素，加入搜索排名计算的原因。</p></blockquote><p>为了从页面性能的角度搞清楚这些变化给我们带来了什么影响，我们需要掌握这些基础知识。<a href="https://developers.google.com/speed/docs/insights/release_notes" target="_blank" rel="noopener">PageSpeed 5.0</a> 是之前版本的一次颠覆性的改动。现在由 Lighthouse 和 <a href="https://developers.google.com/web/updates/2017/12/crux" target="_blank" rel="noopener">CrUX</a> 提供技术支持（Chrome 用户体验报告部）。</p><p><strong>这次升级使用了新的评分算法，将会使获得 PageSpeed 高分更加困难。</strong></p><h3 id="PageSpeed-5-0-有哪些变化"><a href="#PageSpeed-5-0-有哪些变化" class="headerlink" title="PageSpeed 5.0 有哪些变化?"></a>PageSpeed 5.0 有哪些变化?</h3><p>5.0 之前，PageSpeed 会针对测试的页面给出一系列指导意见。如果页面里有很大的、未经压缩的图片，PageSpeed 会建议对图片压缩。再比如，漏掉了 Cache-Headers，会建议加上。</p><p>这些建议是与一些<strong>指导方针</strong>对应的，如果遵从这些指导方针，<strong>很可能</strong>会提升你的页面性能，但这些也仅仅是表层的，它不会分析用户在真实场景下的加载和渲染页面的体验。</p><p>在 PageSpeed 5.0 中，页面在 Lighthouse 的控制下被载入到真实的 Chrome 浏览器中。Lighthouse 从浏览器中获取记录各项指标，把这些指标套入得分模型里计算，最后展示一个整体的性能分。根据具体的分数指标来给出优化的指导方针。</p><p>和 PageSpeed 类似，Lighthouse 也有一个性能分。在 PageSpeed 5.0 中，性能分直接从 Lighthouse 里获取。所以<strong>现在 PageSpeed 的速度分和 Lighthouse 的性能分一样了。</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1d235fa553524?w=1334&h=348&f=png&s=34294" alt="Calibre 在 Google 的 Pagespeed 上获得了 97 分"></p><p>既然我们知道了 PageSpeed 的分数从哪里来，接下来我们就来仔细研究它是如何计算的，以及我们该如何有效的提高页面的性能。</p><h3 id="Google-Lighthouse-是什么"><a href="#Google-Lighthouse-是什么" class="headerlink" title="Google Lighthouse 是什么?"></a>Google Lighthouse 是什么?</h3><p><a href="https://calibreapp.com/blog/lighthouse-reasons/" target="_blank" rel="noopener">Lighthouse</a> 是一个开源项目，由一只来自 Google Chrome 的优秀团队运作。在过去的几年里，它已逐步变成免费的性能分析工具。</p><p>Lighthouse 使用 Chrome 的远程调试协议来获取网络请求的信息、计算 JavaScript 的性能、评估无障碍化级别以及计算用户关注的时间指标，比如 <a href="https://calibreapp.com/docs/metrics/paint-based-metrics" target="_blank" rel="noopener">首次内容绘制时间 First Contentful Paint</a>、<a href="https://calibreapp.com/docs/metrics/time-to-interactive" target="_blank" rel="noopener">可交互时间 Time to Interactive</a> 和速度指标。</p><p>如果你想要深入了解 Lighthouse 的整体架构，请看来自官方的<a href="https://github.com/GoogleChrome/lighthouse/blob/master/docs/architecture.md" target="_blank" rel="noopener">教程</a>。</p><h3 id="Lighthouse-如何计算性能分数"><a href="#Lighthouse-如何计算性能分数" class="headerlink" title="Lighthouse 如何计算性能分数"></a>Lighthouse 如何计算性能分数</h3><p>在性能测试中，Lighthouse 聚焦于用户所见和用户体验，记录了很多指标。</p><p>下面这 6 个指标构成了性能分数的大体部分。他们是：</p><ul><li>可交互时间 Time to Interactive (TTI)</li><li>速度指标 Speed Index</li><li>首次内容绘制时间 First Contentful Paint (FCP)</li><li>首次 CPU 空闲时间 First CPU Idle</li><li>首次有效绘制 First Meaningful Paint (FMP)</li><li>预计输入延迟时间 Estimated Input Latency</li></ul><p>Lighthouse 会针对这些指标运用一个 0 – 100 的分数模型。 这个过程会收集移动端第 75 和第 90 百分位的 <a href="https://httparchive.org/" target="_blank" rel="noopener">HTTP 档案</a>，然后输入到<code>对数正太分布</code>函数（校对者注：这样的话只要性能数据低于 25% 的线上移动端页面，也就是排位在 75% 以下，都给 0 分，而只要比 95% 的移动端页面得分高，就得满分）。</p><p><a href="https://www.desmos.com/calculator/2t1ugwykrl" target="_blank" rel="noopener">根据算法和可交互时间的计算所得数据</a>，我们可以发现，如果一个页面在 2.1 秒内成为“可交互的”，那么它的可交互时间分数指标是 92/100。</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1d235f9a5bfaf?w=1100&h=770&f=png&s=73683" alt></p><p>当每个指标完成计分后会被分配一个权重，用权重调整后算出页面整体的性能分数。权重规则如下：</p><table><thead><tr><th>指标</th><th>权重</th></tr></thead><tbody><tr><td>可交互时间 (TTI)</td><td>5</td></tr><tr><td>速度指标</td><td>4</td></tr><tr><td>首次内容绘制时间</td><td>3</td></tr><tr><td>首次 CPU 空闲时间</td><td>2</td></tr><tr><td>首次有效绘制</td><td>1</td></tr><tr><td>预计输入延迟时间</td><td>0</td></tr></tbody></table><p>这些权重取决于每个指标对移动端用户的体验的影响程度。</p><p>在未来，这些权重在参考来自于 Chrome 用户体验报告的用户观测数据之后，还可能会被进一步优化。</p><p>你可能想知道究竟这每一个指标的权重是如何影响整体得分的。Lighthouse 团队<a href="https://docs.google.com/spreadsheets/d/1Cxzhy5ecqJCucdf1M0iOzM8mIxNc7mmx107o5nj38Eo/edit#gid=0" target="_blank" rel="noopener">打造了一款实用的 Google 电子表格计算器</a>来阐述具体的细节：</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1d235f752c88e?w=1472&h=256&f=png&s=39917" alt="这张电子表格的图片可以用来计算性能分数"></p><p>使用上面的例子，如果我们把可交互时间从 5 秒 变为 17 秒 (全球移动端平均 TTI)，我们的分数会降低到 56% (也就是 100 分之中的 56 分)。</p><p>然而，如果我们把首次内容绘制时间变为 17 秒，我们的分数会是 62%。</p><p><strong>可交互时间 (TTI) 是对你的性能分数影响最大的指标。</strong></p><p>因此，想要得到 PageSpeed 的高分，你<strong>最需要</strong>的是降低 TTI。</p><h3 id="剑指-TTI"><a href="#剑指-TTI" class="headerlink" title="剑指 TTI"></a>剑指 TTI</h3><p>深入来说，有两个对 TTI 影响极大的重要因素：</p><ul><li>传输到页面的 JavaScript 代码的总大小</li><li>主线程上 JavaScript 的运行时间</li></ul><p>我们的<a href="https://calibreapp.com/blog/time-to-interactive/" target="_blank" rel="noopener">可交互时间</a>文章详细说明了 TTI 的工作原理，但如果你想要一些快速无脑的优化，我们建议：</p><p><strong>降低 JavaScript 总大小</strong></p><p>尽可能地，移除无用的 JavaScript 代码，或者只传输当前页面会执行的代码。这可能意味着要移除老的 polyfills 或者尽量采用更小、更新的第三方库。</p><p>你需要记住的是 <a href="https://medium.com/reloading/javascript-start-up-performance-69200f43b201" target="_blank" rel="noopener">JavaScript 花费的</a> 不仅仅是下载它所需要的时间。浏览器需要解压、解析、编译然后才最终执行，这些过程都会消耗不容忽视的时间，尤其在移动设备上。</p><p>能降低你的页面脚本总大小的有效措施是：</p><ul><li>检查并移除对你的用户来说并不需要的 polyfills。</li><li>搞清楚每一个第三方 JavaScript 库所花费的时间。使用 <a href="https://www.npmjs.com/package/webpack-bundle-analyzer" target="_blank" rel="noopener">webpack-bundle-analyser</a> 或者 <a href="https://www.npmjs.com/package/source-map-explorer" target="_blank" rel="noopener">source-map-explorer</a> 来可视化分析他们的大小。</li><li>现代 JavaScript 工具（比如 webpack）可以把大的 JavaScript 应用分解成许多小的 bundles，随着用户的浏览而动态加载。这就是所谓的 <a href="https://webpack.js.org/guides/code-splitting/" target="_blank" rel="noopener">code splitting</a>，它会<strong>极大地优化 TTI。</strong></li><li><a href="https://v8.dev/blog/code-caching-for-devs" target="_blank" rel="noopener">Service workers 会缓存解析和编译后所得的字节码</a>。如果善加利用这个特性，用户只需花费一次解析和编译代码带来的时间损耗，在那之后的结果就会被缓存优化。</li></ul><h3 id="监控可交互时间"><a href="#监控可交互时间" class="headerlink" title="监控可交互时间"></a>监控可交互时间</h3><p>为了较好的展示用户体验的差异性，我们建议使用监控系统（比如 <a href="https://calibreapp.com/" target="_blank" rel="noopener">Calibre</a>），它可以测试页面在两个不同设备上的最小评分；一个较快的桌面端设备和一个中等速度的移动端设备。</p><p>这样的话，你就可以得到你的用户可能体验到的最好和最差两种情况下的数据。是时候意识到，你的用户并没有使用和你一样强大的设备了。</p><h3 id="深度剖析"><a href="#深度剖析" class="headerlink" title="深度剖析"></a>深度剖析</h3><p>为了获得剖析 JavaScript 性能的最好结果，可以刻意使用较慢的移动设备来测试你的页面。如果你的抽屉里有一部老手机，你会发现一片新的天地。</p><p>Chrome DevTools 的硬件仿真模块可以很好的替代真实设备来进行测试，我们写了一个详细的<a href="https://calibreapp.com/blog/react-performance-profiling-optimization/" target="_blank" rel="noopener">性能剖析指南</a>来帮你开始学习分析运行时的性能。</p><h2 id="其他的指标呢？"><a href="#其他的指标呢？" class="headerlink" title="其他的指标呢？"></a>其他的指标呢？</h2><p>速度指标、首次内容绘制时间和首次有效绘制都是以浏览器绘制为基础的指标。他们的影响因素很相似，往往可以被同时优化。</p><p>显然，优化这些指标会相对比较容易，因为他们是通过记录页面的渲染速度来计算的。仔细遵从 Lighthouse 的性能考核准则就能优化这些指标。</p><p>如果你还没有对字体进行预加载或者优化那些关键请求，那从这里入手会是一些很好的切入点。我们的文章，<a href="https://calibreapp.com/blog/critical-request/" target="_blank" rel="noopener">关键请求</a>，详细说明了浏览器针对你的页面是如何发起请求以及渲染关键资源的。</p><h2 id="跟踪过程做出优化"><a href="#跟踪过程做出优化" class="headerlink" title="跟踪过程做出优化"></a>跟踪过程做出优化</h2><p>Google 最近更新了搜索控制台、Lighthouse 和 PageSpeed Insights 针对你的页面的首屏的性能分析有独到之处，但是对于那些需要持续跟踪页面来提升页面性能的团队来说，就显得捉襟见肘了。</p><p><a href="https://calibreapp.com/features" target="_blank" rel="noopener">持续的性能监控</a> 可以保证速度优化，当页面又变差的时候团队也会立刻知晓。人为的测试会对结果引入大量的不可预期的变量，在不同区域、不同设备上的测试在没有专业的实验室环境下几乎是不可能完成的。</p><p>速度已经变成影响了 SEO 排名的关键因素，尤其是目前大约 50% 的页面流量来自于移动设备。</p><p>为了避免排名下降，确保你正在使用最新的性能分析套件来跟踪你的关键页面（哈，我们打造了 <a href="https://calibreapp.com/blog/release-notes-lighthouse-4/" target="_blank" rel="noopener">Calibre</a> 来做你的性能提升伙伴。他以 Lighthouse 为基础。每天都有很多来自全球的团队在使用它）。</p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><ul><li><a href="https://calibreapp.com/blog/time-to-interactive/" target="_blank" rel="noopener">About Time to Interactive</a></li><li><a href="https://calibreapp.com/blog/react-performance-profiling-optimization/" target="_blank" rel="noopener">How to optimise the performance of a JavaScript application</a></li><li><a href="https://docs.google.com/spreadsheets/d/1Cxzhy5ecqJCucdf1M0iOzM8mIxNc7mmx107o5nj38Eo/edit#gid=283330180" target="_blank" rel="noopener">Lighthouse Performance score Calculator</a></li></ul><blockquote><p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im" target="_blank" rel="noopener">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android" target="_blank" rel="noopener">Android</a>、<a href="https://github.com/xitu/gold-miner#ios" target="_blank" rel="noopener">iOS</a>、<a href="https://github.com/xitu/gold-miner#前端" target="_blank" rel="noopener">前端</a>、<a href="https://github.com/xitu/gold-miner#后端" target="_blank" rel="noopener">后端</a>、<a href="https://github.com/xitu/gold-miner#区块链" target="_blank" rel="noopener">区块链</a>、<a href="https://github.com/xitu/gold-miner#产品" target="_blank" rel="noopener">产品</a>、<a href="https://github.com/xitu/gold-miner#设计" target="_blank" rel="noopener">设计</a>、<a href="https://github.com/xitu/gold-miner#人工智能" target="_blank" rel="noopener">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi" target="_blank" rel="noopener">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi" target="_blank" rel="noopener">知乎专栏</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「JavaScript 中 JSON.stringify 的二八法则」</title>
      <link href="/2019/10/24/%E7%BF%BB%E8%AF%91/JavaScript%20%E4%B8%AD%20JSON.stringify%20%E7%9A%84%E4%BA%8C%E5%85%AB%E6%B3%95%E5%88%99/"/>
      <url>/2019/10/24/%E7%BF%BB%E8%AF%91/JavaScript%20%E4%B8%AD%20JSON.stringify%20%E7%9A%84%E4%BA%8C%E5%85%AB%E6%B3%95%E5%88%99/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="http://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html" target="_blank" rel="noopener">The 80/20 Guide to JSON.stringify in JavaScript</a></li><li>原文作者：<a href="http://www.twitter.com/code_barbarian" target="_blank" rel="noopener">Valeri Karpov</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/the-80-20-guide-to-json-stringify-in-javascript.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/the-80-20-guide-to-json-stringify-in-javascript.md</a></li><li>译者：<a href="https://github.com/Jerry-FD" target="_blank" rel="noopener">JerryFD</a></li><li>校对者：<a href="https://github.com/Usey95" target="_blank" rel="noopener">Usey95</a>，<a href="https://github.com/mnikn" target="_blank" rel="noopener">mnikn</a></li></ul></blockquote><h1 id="JavaScript-中-JSON-stringify-的二八法则"><a href="#JavaScript-中-JSON-stringify-的二八法则" class="headerlink" title="JavaScript 中 JSON.stringify 的二八法则"></a>JavaScript 中 JSON.stringify 的二八法则</h1><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" target="_blank" rel="noopener">函数 <code>JSON.stringify()</code></a> 是一个把 JavaScript object 转换成 <a href="https://www.json.org/" target="_blank" rel="noopener">JSON</a> 的标准方法。很多 JavaScript 框架在底层都使用了 <code>JSON.stringify()</code>，例如：<a href="http://expressjs.com/en/4x/api.html#res.json" target="_blank" rel="noopener">Express’ <code>res.json()</code></a>、<a href="https://github.com/axios/axios#example" target="_blank" rel="noopener">Axios’ <code>post()</code></a> 和 <a href="https://webpack.js.org/configuration/stats/" target="_blank" rel="noopener">Webpack stats</a> 都在底层调用了 <code>JSON.stringify()</code>。这篇文章会提供一个实用的、包含异常情况的 <code>JSON.stringify()</code> 的概述。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>几乎所有现代的 JavaScript 运行环境都支持 <code>JSON.stringify()</code>。甚至 IE 浏览器自从 <a href="https://blogs.msdn.microsoft.com/ie/2008/09/10/native-json-in-ie8/" target="_blank" rel="noopener">IE8 起就支持JSON.stringify()</a>。下面是一个把普通的 object 转换成 JSON 的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">answer</span>: <span class="number">42</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str = <span class="built_in">JSON</span>.stringify(obj);</span><br><span class="line">str; <span class="comment">// '&#123;"answer":42&#125;'</span></span><br><span class="line"><span class="keyword">typeof</span> str; <span class="comment">// 'string'</span></span><br></pre></td></tr></table></figure><p>如你所见，下面的例子是 <code>JSON.stringify()</code> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse" target="_blank" rel="noopener"><code>JSON.parse()</code></a> 一起使用的。这种写法可以用来<a href="https://flaviocopes.com/how-to-clone-javascript-object/#json-serialization" target="_blank" rel="noopener">深拷贝 JavaScript 对象</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">answer</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> clone = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"></span><br><span class="line">clone.answer; <span class="comment">// 42</span></span><br><span class="line">clone === obj; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="错误和边界处理"><a href="#错误和边界处理" class="headerlink" title="错误和边界处理"></a>错误和边界处理</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Exceptions" target="_blank" rel="noopener">如果 <code>JSON.stringify()</code> 的参数是 cyclical object，则会抛出一个错误</a>。也就是说，如果对象 <code>obj</code> 有一个属性，这个属性的值是 <code>obj</code> 本身，那么 <code>JSON.stringify()</code> 会抛出一个错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// 循环 object 指向它自身</span></span><br><span class="line">obj.prop = obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出 "TypeError: TypeError: Converting circular structure to JSON"</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj);</span><br></pre></td></tr></table></figure><p>这是 <code>JSON.stringify()</code> 唯一抛出异常的场景，除非你使用自定义的 <code>toJSON()</code> 函数或者使用替代函数（replacer）。然而即便这样，你也还是得把 <code>JSON.stringify()</code> 包在 <code>try/catch</code> 里调用，因为循环 objects 还是可能会出现。</p><p>还有很多边界场景 <code>JSON.stringify()</code> 不会抛出异常，但其结果可能不如你所想。比如，<code>JSON.stringify()</code> 会把 <code>NaN</code> 和 <code>Infinity</code> 转换成 <code>null</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">nan</span>: <span class="built_in">parseInt</span>(<span class="string">'not a number'</span>), <span class="attr">inf</span>: <span class="built_in">Number</span>.POSITIVE_INFINITY &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj); <span class="comment">// '&#123;"nan":null,"inf":null&#125;'</span></span><br></pre></td></tr></table></figure><p><code>JSON.stringify()</code> 也会把属性值为函数或者 <code>undefined</code> 的内容干掉：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, <span class="attr">undef</span>: <span class="literal">undefined</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空 object `JSON.stringify()` 过滤 functions 和 `undefined`。</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj); <span class="comment">// '&#123;&#125;'</span></span><br></pre></td></tr></table></figure><h2 id="优化输出"><a href="#优化输出" class="headerlink" title="优化输出"></a>优化输出</h2><p><code>JSON.stringify()</code> 的第一个参数是要被序列化成 JSON 的 object。实际上 <code>JSON.stringify()</code> 接受 3 个参数，第三个参数 <code>spaces</code>（译注：空隙）。参数 <code>spaces</code> 用来将 JSON 格式化输出成方便阅读的格式。</p><p>参数 <code>spaces</code> 可以是 string 或 number。如果 <code>spaces</code> 不是 undefined，那么<code>JSON.stringify()</code> 则会把 JSON 中的每一个 key 单独作为一行输出，并且加上 <code>spaces</code> 的前缀。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: &#123; <span class="attr">e</span>: <span class="number">4</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// '&#123;"a":1,"b":2,"c":3,"d":&#123;"e":4&#125;&#125;'</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   "a": 1,</span></span><br><span class="line"><span class="comment">//   "b": 2,</span></span><br><span class="line"><span class="comment">//   "c": 3,</span></span><br><span class="line"><span class="comment">//   "d": &#123;</span></span><br><span class="line"><span class="comment">//     "e": 4</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj, <span class="literal">null</span>, <span class="string">'  '</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 2 个空格来格式化 JSON 输出。和上面的例子等价。</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj, <span class="literal">null</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>把参数 <code>spaces</code> 作为字符串使用时，虽然在实际场景中大多是使用空格，但其实不限制必须全是空格。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// __"a": 1,</span></span><br><span class="line"><span class="comment">// __"b": 2,</span></span><br><span class="line"><span class="comment">// __"c": 3,</span></span><br><span class="line"><span class="comment">// __"d": &#123;</span></span><br><span class="line"><span class="comment">// ____"e": 4</span></span><br><span class="line"><span class="comment">// __&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj, <span class="literal">null</span>, <span class="string">'__'</span>);</span><br></pre></td></tr></table></figure><h2 id="Replacers"><a href="#Replacers" class="headerlink" title="Replacers"></a>Replacers</h2><p><code>JSON.stringify()</code> 的第二个参数是 <code>replacer</code> 函数。在上面的例子中，<code>replacer</code> 是 <code>null</code>。JavaScript 针对 object 中的每一个 key/value 对都会调用 replacer 函数，使用函数的返回值作为属性的值。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: &#123; <span class="attr">e</span>: <span class="number">4</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `replacer` 使每个数字的值加 1。输出：</span></span><br><span class="line"><span class="comment">// '&#123;"a":2,"b":3,"c":4,"d":&#123;"e":5&#125;&#125;'</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj, <span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>替代函数（译注：replacer）在过滤敏感词的场景非常有用。例如，假设你想过滤所有<a href="https://masteringjs.io/tutorials/fundamentals/contains-substring#case-insensitive-search" target="_blank" rel="noopener">包含 ‘password’ 及 ‘password’ 子字符串的 keys</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Jean-Luc Picard'</span>,</span><br><span class="line">  password: <span class="string">'stargazer'</span>,</span><br><span class="line">  nested: &#123;</span><br><span class="line">    hashedPassword: <span class="string">'c3RhcmdhemVy'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// '&#123;"name":"Jean-Luc Picard","nested":&#123;&#125;&#125;'</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj, <span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个函数会被调用 5 次。 `key` 等于：</span></span><br><span class="line">  <span class="comment">// '', 'name', 'password', 'nested', 'hashedPassword'</span></span><br><span class="line">  <span class="keyword">if</span> (key.match(<span class="regexp">/password/i</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="函数-toJSON"><a href="#函数-toJSON" class="headerlink" title="函数 toJSON()"></a>函数 <code>toJSON()</code></h2><p><code>JSON.stringify()</code> 函数会遍历 object 寻找含有 <code>toJSON()</code> 函数的属性。如果它找到了 <code>toJSON()</code> 函数，<code>JSON.stringify()</code> 会调用 <code>toJSON()</code> 函数，并使用其返回值作为替代。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Jean-Luc Picard'</span>,</span><br><span class="line">  nested: &#123;</span><br><span class="line">    test: <span class="string">'not in output'</span>,</span><br><span class="line">    toJSON: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'test'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// '&#123;"name":"Jean-Luc Picard","nested":"test"&#125;'</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj);</span><br></pre></td></tr></table></figure><p>函数 <code>toJSON()</code> 可以返回任何值，包括对象、原始类型的值，甚至 <code>undefined</code>。如果 <code>toJSON()</code> 返回 <code>undefined</code>，<code>JSON.stringify()</code> 会忽略这个属性。</p><p>许多 JavaScript 模块使用 <code>toJSON()</code> 这一特性来保证复杂的对象能被正确的序列化。比如 <a href="https://mongoosejs.com/docs/api.html#document_Document-toJSON" target="_blank" rel="noopener">Mongoose documents</a> 和 <a href="https://momentjs.com/docs/#/displaying/as-json/" target="_blank" rel="noopener">Moment objects</a>。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p> 函数 <code>JSON.stringify()</code> 是 JavaScript 基础的核心。许多库和框架在底层都使用了它，所以对 <code>JSON.stringify()</code> 的扎实理解，可以帮助更好的学习你感兴趣的 npm 模块。比如，针对你的 Express REST API，可以借用自定义 <code>toJSON()</code> 函数的能力来处理原生的 <code>Date</code> 类，以此实现一个<a href="https://masteringjs.io/tutorials/fundamentals/date_format" target="_blank" rel="noopener">日期格式化</a> 的替代方案，或者，当使用 Axios 发送 HTTP 请求时，确保客户端的循环对象能被正确的转换成 JSON。（译注：帕累托法则即 80/20 Rule，一般指 20% 的输入，决定 80% 的结果的现象。）</p><blockquote><p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im" target="_blank" rel="noopener">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android" target="_blank" rel="noopener">Android</a>、<a href="https://github.com/xitu/gold-miner#ios" target="_blank" rel="noopener">iOS</a>、<a href="https://github.com/xitu/gold-miner#前端" target="_blank" rel="noopener">前端</a>、<a href="https://github.com/xitu/gold-miner#后端" target="_blank" rel="noopener">后端</a>、<a href="https://github.com/xitu/gold-miner#区块链" target="_blank" rel="noopener">区块链</a>、<a href="https://github.com/xitu/gold-miner#产品" target="_blank" rel="noopener">产品</a>、<a href="https://github.com/xitu/gold-miner#设计" target="_blank" rel="noopener">设计</a>、<a href="https://github.com/xitu/gold-miner#人工智能" target="_blank" rel="noopener">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi" target="_blank" rel="noopener">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi" target="_blank" rel="noopener">知乎专栏</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「高清方案」</title>
      <link href="/2019/09/12/%E6%80%BB%E7%BB%93/%E9%AB%98%E6%B8%85%E6%96%B9%E6%A1%88/"/>
      <url>/2019/09/12/%E6%80%BB%E7%BB%93/%E9%AB%98%E6%B8%85%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>viewport -&gt; 视口<br>layoutviewport  -&gt; 布局视口<br>visualviewport -&gt; 虚拟视口<br>物理像素 -&gt; 屏幕的真实像素<br>设备独立像素 -&gt; 操作系统 (广义) 中可以操作控制的像素<br>设备像素比 -&gt; 物理像素/设备独立像素<br>ppi -&gt; 每英寸多少个像素 -&gt;  决定物理像素的单位实际大小<br>rem -&gt; 尺寸单位，根据 html 根节点的 font-size 决定</p><blockquote><p>假设设备像素比大于 1 ， css 中定义的的 1 个像素，就会有多个物理像素来真实渲染在屏幕上。</p></blockquote><h3 id="高清方案实现原理"><a href="#高清方案实现原理" class="headerlink" title="高清方案实现原理"></a>高清方案实现原理</h3><ul><li>Html 引入 js 脚本 -&gt; 根据设备的型号、物理像素比 (dpr) 和屏幕尺寸，动态改写 meta 标签，设置缩放比例，给 html 标签添加 2 个属性，处理后的 dpr 和 font-size ，用于在 css 中描述尺寸时所用的单位。</li></ul><blockquote><p>对 dpr 处理具体内容是 IOS 中对 dpr 设置最大值 3，安卓统一为 1</p></blockquote><ul><li>通过 css 处理器 postcss 来改变项目写的样式</li><li>webpack 结合 postcss 以及 postcss 的插件 postcss-px2rem 来把 css 中写的 px 无痛转换为 rem</li></ul><p>参考文档:</p><ul><li><a href="https://github.com/amfe/article/issues/17" target="_blank" rel="noopener">使用Flexible实现手淘H5页面的终端适配 · Issue #17 · amfe/article · GitHub</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 适配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「前端导出 Excel/csv 文件」</title>
      <link href="/2016/06/22/%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E5%AF%BC%E5%87%BA%20excel-csv%20%E6%96%87%E4%BB%B6/"/>
      <url>/2016/06/22/%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E5%AF%BC%E5%87%BA%20excel-csv%20%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="前端导出excel-csv文件"><a href="#前端导出excel-csv文件" class="headerlink" title="前端导出excel/csv文件"></a>前端导出excel/csv文件</h3><h3 id="安装所需js"><a href="#安装所需js" class="headerlink" title="安装所需js"></a>安装所需js</h3><p><a href="https://github.com/eligrey/FileSaver.js/" target="_blank" rel="noopener">fileSaver</a><br><a href="https://github.com/eligrey/Blob.js" target="_blank" rel="noopener">Blob</a></p><p>安装基于npm,先确认安装了nodeJS。进入项目目录，在根目录下打开终端执行行以下代码</p><p><code>npm install file-saver --save</code></p><p><code>bower install file-saver</code></p><p>安装完成后可以看到在node_modules文件里新增的文件夹file-saver和filesaver 其中 filesaver文件夹为filesaver.js源码</p><h3 id="引用fileSaver"><a href="#引用fileSaver" class="headerlink" title="引用fileSaver"></a>引用fileSaver</h3><p>在需要下载导出页面对应的JS文件处引入filesaver文件</p><p><code>import FileSaver from &#39;file-saver&#39;;</code></p><p><code>const {saveAs} = FileSaver;</code></p><h3 id="新建Blob对象"><a href="#新建Blob对象" class="headerlink" title="新建Blob对象"></a>新建Blob对象</h3><blockquote><p>BLOB (binary large object)，二进制大对象，是一个可以存储二进制文件的容器。(来自百度百科)</p></blockquote><p><code>var Blob = new Blob([&quot;JSON&quot;],{type:&#39;&#39;})</code></p><h5 id="blob的结构"><a href="#blob的结构" class="headerlink" title="blob的结构"></a>blob的结构</h5><ul><li>Blob(blobParts[, options])</li></ul><h5 id="更多Blob-资料"><a href="#更多Blob-资料" class="headerlink" title="更多Blob 资料"></a>更多<a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank" rel="noopener">Blob</a> 资料</h5><h3 id="引用saveAs"><a href="#引用saveAs" class="headerlink" title="引用saveAs"></a>引用saveAs</h3><p><code>saveAs(Blob,filename,boolean)</code></p><p>第三个参数boolean如果传true filesaver.js就不会对你的文件自动设置类型</p><blockquote><p>new Blob有浏览器兼容问题，如需考虑浏览器兼容问题，需要引入<a href="https://github.com/eligrey/Blob.js" target="_blank" rel="noopener">Blob.js</a></p></blockquote><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clickhandle</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob</span><br><span class="line">(</span><br><span class="line">[<span class="string">"Hello, world!"</span>],</span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">"text/plain;charset=utf-8"</span>&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">saveAs(blob, <span class="string">"hello world.txt"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意下载导出功能只能写在事情回调函数里，如某个button的onClick事件中</p></blockquote><h3 id="导出文件类型"><a href="#导出文件类型" class="headerlink" title="导出文件类型"></a>导出文件类型</h3><ul><li>csv</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exportContent = <span class="string">"\uFEFF"</span>;</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([exportContent+data(<span class="string">""</span>)],</span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">"text/plain;charset=utf-8"</span>&#125;</span><br><span class="line">);</span><br><span class="line">saveAs(blob, downloadName + <span class="string">".csv"</span>);</span><br></pre></td></tr></table></figure><ul><li>excel</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exportContent = <span class="string">"\uFEFF"</span>;</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([exportContent+data(<span class="string">""</span>)], &#123;</span><br><span class="line">type: <span class="string">"application/vnd.ms-excel;charset=charset=utf-8"</span></span><br><span class="line">&#125;);</span><br><span class="line">saveAs(blob, downloadName + <span class="string">".xls"</span>);</span><br></pre></td></tr></table></figure><p>其中加入exportContent = “\uFEFF”;可以防止中文乱码</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>「关于 Cookie 的学习笔记」</title>
      <link href="/2016/06/08/%E6%80%BB%E7%BB%93/%E5%85%B3%E4%BA%8E%20cookie%20%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2016/06/08/%E6%80%BB%E7%BB%93/%E5%85%B3%E4%BA%8E%20cookie%20%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="关于cookie的学习笔记"><a href="#关于cookie的学习笔记" class="headerlink" title="关于cookie的学习笔记"></a>关于cookie的学习笔记</h2><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><ul><li>cookie的定义</li></ul><blockquote><p>cookie是前端开发中的一个重要概念。cookie翻译为“甜饼干”,由W3C提出被各大浏览器支持的一种解决HTTP请求无状态的方案。<br>http的无状态是指客服端和服务端的数据交换完毕，连接一旦中断，再次建立连接时又是一个全新的连接，之前的连接的数据会被彻底“遗忘”，这就使服务端无法弄明白这次的连接是由谁发起的。</p></blockquote><ul><li>cookie的使用场景</li></ul><p>当用户浏览网站需要对用户身份进行判断，来进行不同响应时，可以利用cookie。第一次发送请求判断校验了用户身份后，把用户身份存放在cookie中，当下次发送请求时服务端就可从cookie中获取之前存放在cookie中信息，而不用再次经过复杂校验。<br>或是用来保存一些用户在网页上自定义的一些设置，在页面跳转、页面关闭后依然能够记录这些信息。针对不同用户的不同操作做出相应的响应、</p><ul><li>cookie的前端封装代码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cookie = &#123;</span><br><span class="line"><span class="keyword">set</span>:function(key,val,time)&#123;<span class="comment">//设置cookie方法</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">//获取当前时间</span></span><br><span class="line">date.setDate(date.getTime() + time)<span class="comment">//设置cookie过期时间</span></span><br><span class="line"><span class="built_in">document</span>.cookie = key + <span class="string">"="</span> + val +</span><br><span class="line">((time==<span class="literal">null</span>) ? <span class="string">''</span> : <span class="string">';expires='</span>+date.toGMTString())</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">get</span>:function(key)&#123;<span class="comment">//获取cookie方法</span></span><br><span class="line"><span class="comment">/*获取cookie参数*/</span></span><br><span class="line"><span class="comment">//删除cookie中的所有空格;</span></span><br><span class="line"><span class="keyword">var</span> pureCookie = <span class="built_in">document</span>.cookie.replace(<span class="regexp">/\s+/g</span>,<span class="string">""</span>);</span><br><span class="line"><span class="comment">//以分号分割cookie存放在arrCookie中</span></span><br><span class="line"><span class="keyword">var</span> arrCookie = pureCookie.split(<span class="string">";"</span>);</span><br><span class="line"><span class="comment">//声明要输出的值</span></span><br><span class="line"><span class="keyword">var</span> resultVal;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历arrCookie找出与输入相同的键值对，输出相应值</span></span><br><span class="line">arrCookie.map(<span class="function">(<span class="params">item,index</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">var</span> result = item.split(<span class="string">"="</span>);</span><br><span class="line"><span class="keyword">if</span>(key == result[<span class="number">0</span>])&#123;</span><br><span class="line">resultVal = result[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> resultVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码中封装了一个cookie对象，它包含2个方法set和get。</p><p>set可以设置cookie，其中包含3个参数，cookie的属性名，cookie的值，cookie的过期时间</p><p>get可以取出与输入属性名相同的cookie值</p></blockquote><ul><li><p>cookie的属性</p></li><li><p>max-age(expires):指定cookie的有效期，单位是秒，表示cookie存在的秒数</p></li></ul><ol><li>max-age为负:表示此cookie只在本窗口和子窗口有效</li><li>max-age为0:表示删除此cookie</li></ol><ul><li><p>domain:可以访问该cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”</p></li><li><p>path:可以访问该cookie的域名。如果设置为“/”，则该域名下的所有路径都可以访问该Cookie。注意最后一个字符必须为“/”</p></li><li><p>cookie存在的问题</p></li><li><p>存储大小只有4kb</p></li><li><p>每次发送http请求时cookie都会一并发送，浪费带宽</p></li><li><p>HTML5的 <a href="http://baidu.com/" target="_blank" rel="noopener">localStorage</a>和sessionStorage有了更好的解决办法</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
